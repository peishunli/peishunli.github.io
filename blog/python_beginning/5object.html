<!DOCTYPE html>
<html>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a4d4cfbf5559c427ea39c9814a033024";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<head>
  <title>对象 - peishunli.site</title>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="..\..\favicon.ico" type="image/ico">
  <link rel="stylesheet" type="text/css" href="..\..\css\site.min.css">
  <script type="text/javascript" async="async" src="..\..\mathjax\MathJax.js?config=TeX-AMS_HTML"></script>
  <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
  <link href="..\..\tipuesearch\tipuesearch.css" rel="stylesheet">
  <script src="..\..\tipuesearch\tipuesearch_set.js"></script>
  <script src="..\..\tipuesearch\tipuesearch.min.js"></script>
</head>
<body>
<div id="topbar">
  <div style="display: block; float: right">
  <form action="..\..\search.html">
  <input type="text" placeholder="Search Here" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
  </div>
</div>
<ul class="breadcrumb"><li><a href="..\..\index.html">HOME</a></li><li><a href="..\posts.html">POSTS</a></li><li><a href="..\posts.html#PYTHON_BEGINNING">PYTHON_BEGINNING</a></li><li class="active">对象</li></ul>

<div id="view">
<div class="toc">
<ul>
<li><a href="#1">1 对象的魔力</a><ul>
<li><a href="#11">1.1 多态</a></li>
<li><a href="#12">1.2 封装</a></li>
<li><a href="#13">1.3 继承</a></li>
</ul>
</li>
<li><a href="#2">2 类和类型</a><ul>
<li><a href="#21">2.1 创建自己的类</a></li>
<li><a href="#22">2.2 属性和方法</a></li>
<li><a href="#23">2.3 类的命名空间</a></li>
<li><a href="#24">2.4 继承父类</a></li>
<li><a href="#25">2.5 调查继承</a></li>
<li><a href="#26">2.6 多个父类</a></li>
</ul>
</li>
<li><a href="#3">3 生成器</a><ul>
<li><a href="#31">3.1 创建生成器</a></li>
<li><a href="#32">3.2 递归生成器</a></li>
</ul>
</li>
</ul>
</div>
<div id="container">

<p>之前介绍了Python主要的内建对象类型（数字int、字符串str、列表list、元组tuple和字典dict），以及内建函数和标准库的用法，还有自定义函数的方式。接下来将介绍如何创建自己的对象？<br />
为什么要自定义对象呢？使用字典、序列、数字和字符串来创建函数，完成这项工作还不够吗？这样做当然可以，但是创建自己的对象（尤其是类型或者被称为<strong>类</strong>的对象）是Python的核心概念，事实上，Python被称为面向对象的语言（和C++、Java一样）。接下来会介绍如何<strong>创建对象</strong>，以及<strong>多态、封装、方法、属性、父类</strong>以及<strong>继承</strong>的概念。</p>
<h3 id="1">1 对象的魔力</h3>
<p>对象可以看做数据（属性）以及一系列可以存取、操作这些数据的方法所组成的集合。使用对象替代全局变量和函数的原因可能有很多，其中对象最重要的优点如下：</p>
<h4 id="11">1.1 多态</h4>
<p>多态（Polymorphism）意味着就算不知道变量所引用的对象类型是什么，还是能对它进行操作，而它会根据对象（或类）类型的不同而表现出不同的行为。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="s">&#39;abc&#39;</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>1
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>1
</pre></div>
</td></tr></table>

<p>对于变量x来说，不需要知道它是字符串还是列表，就可以调用它的count方法—不用管它是什么类型（只要提供一个字符作为参数即可）。  <br />
任何不知道对象到底是什么类型，但是又要对对象“做点什么”的时候，都会用到多态。这不仅限于方法，很多内建运算符和函数都有多态的性质：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="mi">1</span><span class="o">+</span><span class="mi">2</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>3
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="s">&#39;Fish &#39;</span><span class="o">+</span><span class="s">&#39;license&#39;</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&#39;Fish license&#39;
</pre></div>
</td></tr></table>

<h4 id="12">1.2 封装</h4>
<p>封装是可以不关心对象是如何构建的而直接进行使用。如何将变量“封装”在对象内？可以将其作为<strong>属性</strong>（attribute）存储。正如方法一样，属性是对象内部的变量。  <br />
对象有它自己的状态（state），对象的状态由它的属性（比如名称）来描述。对象的方法可以改变它的属性。</p>
<h4 id="13">1.3 继承</h4>
<p>如果已经有了一个类，而又想建立一个非常类似的呢？新的类可能只是添加几个方法。这时就会用到<strong>继承</strong>。</p>
<h3 id="2">2 类和类型</h3>
<p>类将它视为<strong>种类</strong>或<strong>类型</strong>的同义词，代表对象的集合。类的主要任务是定义它的实例会用到的方法。所有的对象都属于某一个类，称为类的实例。当一个对象所属的类是另外一个对象所属类的子集时，前者就被称为后者的<strong>子类</strong>（subclass），所以“百灵鸟类”是“鸟类”的子类。相反，“鸟类”是“百灵鸟类”的<strong>父类</strong>（superclass）。    <br />
Python中，习惯上使用单数名词，并且首字母大写，比如Bird和Lark，来描述对象的类。</p>
<h4 id="21">2.1 创建自己的类</h4>
<p>先来看一个简单的类：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">__metaclass__</span><span class="o">=</span><span class="nb">type</span>   <span class="c">#或class Person(object)  确定使用新式类</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>
    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Hello, world! I&#39;m </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
<span class="n">foo</span><span class="o">=</span><span class="n">Person</span><span class="p">()</span>
<span class="n">foo</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&#39;Luke Skywalker&#39;</span><span class="p">)</span>
<span class="n">foo</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Hello, world! I&#39;m Luke Skywalker
</pre></div>
</td></tr></table>

<p><strong>注意</strong> 尽管可能使用的是新版的Python，但一些功能不会在旧式类上起作用。为了确保类是新型的，需要在模块或者脚本开始的地方放置赋值语句__metaclass__=type，或者继承新式类（比如object类，也就是子类化内建类object）。新式类必然包含了更多的功能，也是之后推荐的写法，从写法上区分的话，如果当前类或者父类继承了object类，那么该类便是新式类。</p>
<p>在调用foo的setName和greet函数时，foo自动将自己作为第一个参数传人函数中—因此形象地命名为self。显然这就是self的用处和存在的必要性。没有它，成员方法就没法访问它们要对其属性进行操作的对象本身了。  <br />
<strong>属性是可以在外部访问的：</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">foo</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&#39;Luke Skywalker&#39;
</pre></div>
</td></tr></table>

<h4 id="22">2.2 属性和方法</h4>
<p>self参数事实上正是方法和函数的区别。方法将它们的第一个参数绑定到所属的实例上，因此这个参数可以不必提供。   <br />
属性只是作为对象的一部分变量，方法则是存储在对象内的函数。</p>
<p><strong>2.2.1 私有化</strong>     <br />
默认情况下，程序可以从外部访问一个对象的属性。但是有时候需要使用<strong>私有属性</strong>，这是外部对象无法访问的，但是通过getName和setName等<strong>访问器</strong>（accessor）能够访问这些私有属性。<br />
为了让方法或者属性变为私有，只要在它的<strong>名字前面加上双下划线</strong>即可：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Secretive</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__inaccessible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>
    <span class="k">def</span> <span class="nf">accessible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;The secret message is: &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__inaccessible</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>现在__inaccessible从外界是无法访问的，而在内部还能使用(比如从accessible)访问：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">=</span><span class="n">Secretive</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">__inaccessible</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-4-ffe7eb44855c&gt; in &lt;module&gt;()
      1 s=Secretive()
----&gt; 2 s.__inaccessible()


AttributeError: Secretive instance has no attribute &#39;__inaccessible&#39;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">.</span><span class="n">accessible</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre>The secret message is: 
Hello, world!
</pre></div>
</td></tr></table>

<p>类的内部定义中，所有以双下划线开始的名字（方法或属性）都被“翻译”成前面加上单下划线和类名的形式。在了解了这些幕后的事情后，实际上还是能在类外访问这些私有方法，尽管不应该这么做：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">.</span><span class="n">_Secretive__inaccessible</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Hello, world!
</pre></div>
</td></tr></table>

<p>简而言之，确保其他人不会访问对象的方法和属性是不可能的，但是通过这类“名称变化术”就是他们不应该访问这些方法和属性的强有力信号。</p>
<p><strong>2.2.2 访问器方法</strong>   <br />
访问器是一个简单的方法，它能使用getHeight、setHeight这样的名字来得到或者重绑定一些属性：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Rectangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__inf__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">setSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="n">size</span>
    <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span>
<span class="n">r</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="mi">10</span>
<span class="n">r</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="mi">5</span>
<span class="n">r</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>(10, 5)
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">r</span><span class="o">.</span><span class="n">setSize</span><span class="p">((</span><span class="mi">150</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="n">r</span><span class="o">.</span><span class="n">width</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>150
</pre></div>
</td></tr></table>

<p>在上面的例子中，getSize和setSize方法是一个名为size的假想属性的访问器方法，size是由width和height构成的元组。如果有一天要改变类的实现，将size变成一个真正的属性，这样width和height就可以动态算出，那么就要把它们放到一个访问器方法中去。但如果有很多简单的属性，那么就不现实了。如果那么做就得写很多访问器方法。那么怎么解决呢？这就需要用到property函数。   <br />
<strong>property函数</strong>    <br />
property函数的使用很简单。延续上面的Rectangle类，只要增加一行代码（子类化object，或者使用__metaclass__=type）:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">__metaclass__</span><span class="o">=</span><span class="nb">type</span>
<span class="k">class</span> <span class="nc">Rectangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__inf__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">setSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="n">size</span>
    <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span>
    <span class="n">size</span><span class="o">=</span><span class="nb">property</span><span class="p">(</span><span class="n">getSize</span><span class="p">,</span><span class="n">setSize</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>在新版的Rectangle中，property函数创建了一个属性size，其中访问器方法被当做参数（先是取值，然后是赋值）。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">()</span>
<span class="n">w</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="mi">10</span>
<span class="n">w</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="mi">5</span>
<span class="n">w</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>(10, 5)
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="mi">100</span>
<span class="n">w</span><span class="o">.</span><span class="n">width</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>150
</pre></div>
</td></tr></table>

<p>很显然，size属性仍然取决于getSize和setSize中的计算。但它看起来就像普通的属性一样。实际上，property函数可以用fget，fset，fdel和doc-这四个参数来调用。如果没有参数，产生的属性既不可读，也不可写。如果只使用一个参数调用（一个取值方法），产生的属性是只读的。第三个参数（可选）是一个用于删除属性的方法。第四个参数（可选）是一个文档字符串。</p>
<p><strong>2.2.3 特殊方法</strong>     <br />
在Python中，有的名称（方法名）在<strong>前面和后面都加上两个下划线</strong>，比如__future__，这样拼写表示名字有特殊含义，所以绝不要在自己的程序中使用这种名字。由这些名字组成的集合所包含的方法称为<strong>特殊</strong>方法。如果对象实现了这些方法的某一个，那么这个方法会在特殊的情况下被Python调用。而几乎没有直接调用它们的必要。</p>
<p><strong>(1) 构造方法</strong></p>
<p>首先要讨论的第一个特殊方法是构造方法。构造方法是一个很奇怪的名字，它代表着类似于以前例子中使用过的那种名为init的初始化方法。但构造方法和其他普通方法不同的地方在于，当一个对象被创建后，会立即调用构造方法。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">FooBar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somevar</span><span class="o">=</span><span class="mi">42</span>
<span class="n">f</span><span class="o">=</span><span class="n">FooBar</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">somevar</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>42
</pre></div>
</td></tr></table>

<p><strong>(2) 重写一般方法和特殊的构造方法</strong>  <br />
如果一个方法在B类的一个实例中被调用（或一个属性被访问），但在B类中没有找到该方法，那么就会去它的父类A里面找：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;hello, I&#39;m A&quot;</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">a</span><span class="o">=</span><span class="n">A</span><span class="p">()</span>
<span class="n">b</span><span class="o">=</span><span class="n">B</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>hello, I&#39;m A
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">b</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>hello, I&#39;m A
</pre></div>
</td></tr></table>

<p>在子类中增加功能最基本的方式就是增加方法。但是也可以<strong>重写</strong>一些父类的方法来自定义继承的行为。B类也能重写这个方法。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;hello, I&#39;m B&quot;</span>
<span class="n">b</span><span class="o">=</span><span class="n">B</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>  
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>hello, I&#39;m B
</pre></div>
</td></tr></table>

<p>重写是继承机制中的一个重要内容，但是对于构造方法尤其重要。构造方法用来初始化新创建对象的状态，大多数子类不仅要拥有自己的初始化代码，还要拥有父类的初始化代码。虽然重写的机制对于所有方法来说都是一样的，但是当重写构造方法时，更可能遇到特别的问题：如果一个类的构造方法被重写，那么就需要调用父类的构造方法，否则对象可能不会被正确的初始化。如下：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bird</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hungry</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hungry</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Aaaah...&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hungry</span><span class="o">=</span><span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;No,thanks!&#39;</span>
<span class="n">b</span><span class="o">=</span><span class="n">Bird</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Aaaah...
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">b</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>No,thanks!
</pre></div>
</td></tr></table>

<p>可以看到，鸟吃过了以后，就不会再饥饿。现在考虑子类SongBird，它添加了唱歌的行为。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">SongBird</span><span class="p">(</span><span class="n">Bird</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sound</span><span class="o">=</span><span class="s">&#39;Squawk!&#39;</span>
    <span class="k">def</span> <span class="nf">sing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">sound</span>
<span class="n">sb</span><span class="o">=</span><span class="n">SongBird</span><span class="p">()</span>
<span class="n">sb</span><span class="o">.</span><span class="n">sing</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Squawk!
</pre></div>
</td></tr></table>

<p>因为SongBird是Bird的一个子类，它继承了eat方法，但如果调用eat方法，就会产生一个问题：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">sb</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-19-05f67b3cf162&gt; in &lt;module&gt;()
----&gt; 1 sb.eat()


&lt;ipython-input-14-d86c7aaa626a&gt; in eat(self)
      3         self.hungry=True
      4     def eat(self):
----&gt; 5         if self.hungry:
      6             print &#39;Aaaah...&#39;
      7             self.hungry=False


AttributeError: SongBird instance has no attribute &#39;hungry&#39;
</pre></div>
</td></tr></table>

<p>异常很清楚地说明了错误：SongBird没有hungry属性。原因是：在SongBird中，构造方法被重写，但新的构造方法没有任何关于初始化hungry属性的代码。为了达到预期的效果，SongBird的构造方法必须调用其父类Bird的构造方法来确保进行基本的初始化。有两种方法能达到这个目的，如下： </p>
<p><strong><em>调用未绑定的父类构造方法</em></strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">SongBird</span><span class="p">(</span><span class="n">Bird</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Bird</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sound</span><span class="o">=</span><span class="s">&#39;Squawk!&#39;</span>
    <span class="k">def</span> <span class="nf">sing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">sound</span>
<span class="n">sb</span><span class="o">=</span><span class="n">SongBird</span><span class="p">()</span>
<span class="n">sb</span><span class="o">.</span><span class="n">sing</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Squawk!
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">sb</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Aaaah...
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">sb</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>No,thanks!
</pre></div>
</td></tr></table>

<p>通过将当前的实例作为self参数提供给未绑定方法，SongBird就能够使用其父类构造方法的所有实现，也就是说属性hungry能被设置。</p>
<p><strong><em>使用super函数</em></strong>  <br />
super函数只能在新式类中使用。当前的类和对象可以作为super函数的参数使用，调用函数返回的是父类的方法，而不是当前类的方法。如下：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">__metaclass__</span><span class="o">=</span><span class="nb">type</span>
<span class="k">class</span> <span class="nc">SongBird</span><span class="p">(</span><span class="n">Bird</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SongBird</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sound</span><span class="o">=</span><span class="s">&#39;Squawk!&#39;</span>
    <span class="k">def</span> <span class="nf">sing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">sound</span>
<span class="n">sb</span><span class="o">=</span><span class="n">SongBird</span><span class="p">()</span>
<span class="n">sb</span><span class="o">.</span><span class="n">sing</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Squawk!
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">sb</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Aaaah...
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">sb</span><span class="o">.</span><span class="n">eat</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>No,thanks!
</pre></div>
</td></tr></table>

<p><strong>(3) 成员访问方法</strong></p>
<p>接下来介绍一些处理对象访问的方法，这些方法允许你创建自己的序列或者映射。   <br />
基本的序列和映射规则很简单，但如果要实现它们全部功能就需要实现很多特殊函数。下面将会说到：</p>
<p><strong><em>基本的序列和映射规则</em></strong>     <br />
序列和映射是对象的集合。为了实现它们基本的行为（规则），如果对象是不可变的（如字符串和元组）。那么就需要使用两个特殊方法，如果是可变的（列表和字典），则需要使用4个。</p>
<p>a. __len__(self):这个方法返回集合中所含对象的数量。对于序列来说，这就是元素的个数；对于映射来说，则是键-值对的数量。</p>
<p>b. __getitem__(self,key):这个方法返回与所给键对应的值。对于序列来说，键应该是一个0~n-1的整数（或者像后面所说的负数）；对于映射来说，可以使用任何种类的键。</p>
<p>c. __setitem__(self,key,value):这个方法按一定的方式存储和key关联的value，该值随后可使用 __getitem__来获取。当然，只能为可以修改的对象定义这个方法。</p>
<p>d. __delitem__(self,key):这个方法在对一部分对象使用del语句时被调用，同时删除和键关联的值。这个方法也是为可修改的对象定义的。     </p>
<p>对这些方法的要求：   <br />
a. 对于一个序列来说，如果键是负整数，那么要从末尾开始计数。换句话说就是x[-n]和x[len(x)-n]是一样的；  <br />
b. 如果键是不合适的类型（例如，对序列使用字符串作为键），会引发一个TypeError异常;    <br />
c. 如果序列的索引是正确的类型，但超出了范围，会引发一个IndexError异常。   <br />
让我们实践一下—看看如果创建一个<strong>无穷序列</strong>，会发生什么：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">def</span> <span class="nf">checkIndex</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;所给的键能接受索引吗？</span>
<span class="sd">    为了能被接受，键应该是一个非负的整数，如果它不是一个整数，比如是字符串，会引发TypeError;</span>
<span class="sd">    如果它是负数，则会引发IndexError（因为序列是无限长的）。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="nb">long</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span>
<span class="k">class</span> <span class="nc">ArithmeticSequence</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;初始化算数序列</span>
<span class="sd">        初始值-序列中的第一个值</span>
<span class="sd">        步长-两个相邻值之间的差别</span>
<span class="sd">        改变-用户修改的值的字典</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">=</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="o">=</span><span class="p">{}</span>  <span class="c">#没有项被修改</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an item from the arithmetic sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">checkIndex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>             <span class="c">#修改了吗？</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>                         <span class="c">#否则...</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="n">key</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span>      <span class="c">#...计算值</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;修改算术序列中的一个项</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">checkIndex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
<span class="n">s</span><span class="o">=</span><span class="n">ArithmeticSequence</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>9
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
<span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>11
</pre></div>
</td></tr></table>

<p>注意，没有实现__del__方法的原因是我希望删除元素是非法的：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">del</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-6-9cf88d1604ce&gt; in &lt;module&gt;()
----&gt; 1 del s[4]


AttributeError: ArithmeticSequence instance has no attribute &#39;__delitem__&#39;
</pre></div>
</td></tr></table>

<p>这个类没有__len__方法，因为它是无限长的。   <br />
索引检查是通过用户自定义的checkIndex函数实现的。如果使用了一个非法类型的索引，就会引发TypeError异常，如果索引的类型是正确的但超出了范围，则会引起IndexError异常：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="p">[</span><span class="s">&#39;four&#39;</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-7-f34801bc947b&gt; in &lt;module&gt;()
----&gt; 1 s[&#39;four&#39;]


&lt;ipython-input-3-6350fc4de34b&gt; in __getitem__(self, key)
     21         &quot;&quot;&quot;Get an item from the arithmetic sequence.
     22         &quot;&quot;&quot;
---&gt; 23         checkIndex(key)
     24         try:
     25             return self.changed[key]             #修改了吗？


&lt;ipython-input-3-6350fc4de34b&gt; in checkIndex(key)
      5     &quot;&quot;&quot;
      6     if not isinstance(key,(int,long)):
----&gt; 7         raise TypeError
      8     if key&lt;0:
      9         raise IndexError


TypeError:
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-8-d1e9953ed446&gt; in &lt;module&gt;()
----&gt; 1 s[-4]


&lt;ipython-input-3-6350fc4de34b&gt; in __getitem__(self, key)
     21         &quot;&quot;&quot;Get an item from the arithmetic sequence.
     22         &quot;&quot;&quot;
---&gt; 23         checkIndex(key)
     24         try:
     25             return self.changed[key]             #修改了吗？


&lt;ipython-input-3-6350fc4de34b&gt; in checkIndex(key)
      7         raise TypeError
      8     if key&lt;0:
----&gt; 9         raise IndexError
     10 class ArithmeticSequence:
     11     def __init__(self,start=0,step=1):


IndexError:
</pre></div>
</td></tr></table>

<p><strong>(4) __getattr__和__setattr__</strong>   <br />
拦截（intercept）对象的所有属性访问是可能的，这样可以用旧式类实现属性。为了在访问属性的时候可以执行代码，必须使用一些特殊方法。下面的4种方法提供了需要的功能（在旧式类中只需要后3个）</p>
<p>a. __getattribute__(self,name):当属性name被访问时自动被调用（只能在新式类中使用）；</p>
<p>b. __getattr__(self,name):当属性name被访问且对象没有相应的属性时被自动调用；</p>
<p>c. __setattr__(self,name,value): 当试图给属性name赋值时会被自动调用；</p>
<p>d. __delattr__(self,name): 当试图删除属性name时会被自动调用。</p>
<p>尽管和使用property函数相比有点复杂（而且在某些方面效率更低），但是这些特殊方法是很强大的，因为可以对处理很多属性的方法进行再编码。   <br />
下面还是Rectangle的例子，但这次使用的是特殊方法：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Rectangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span><span class="s">&#39;size&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span><span class="s">&#39;size&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">()</span>
<span class="n">w</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>(0, 0)
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">__dict__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>{&#39;height&#39;: 0, &#39;width&#39;: 0}
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="n">w</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>(2, 6)
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">width</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">hasattr</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>True
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">age</span><span class="o">=</span><span class="mi">28</span>
<span class="n">w</span><span class="o">.</span><span class="n">age</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>28
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">w</span><span class="o">.</span><span class="n">__dict__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>{&#39;age&#39;: 28, &#39;height&#39;: 6, &#39;width&#39;: 2}
</pre></div>
</td></tr></table>

<p>注意： __setattr__方法在所涉及的属性不是size时也会被调用。如果属性是size，那么就像前面那样执行操作，否则就要使用特殊方法__dict__，该方法包含一个字典，字典里是所有实例的属性；   <br />
__getattr__方法只在普通的属性没有被找到的时候调用。</p>
<p><strong>(5) 迭代器</strong>    <br />
迭代的意思是重复做一些事很多次—就像在循环中做的那样。到现在为止只有在for循环中对序列和字典进行迭代，但实际上也能对其他的对象进行迭代：实现__iter__特殊方法的对象。   <br />
__iter__方法返回一个迭代器（iterator），所谓的迭代器就是具有next方法（这个方法在调用时不需要任何参数）的对象。在调用next方法时，迭代器会返回它的下一个值。     <br />
迭代规则的关键是什么？为什么不使用列表？因为列表的杀伤力太大。如果有可以一个接一个地计算值的函数，那么在使用时可能是计算一个值时获取一个值-而不是通过列表一次性获取所有值。如果有很多值，列表就会占用太多的内存。另外，使用迭代器更通用、更简单、更优雅。让我们看看一个不使用列表的例子，因为要用的话，列表的长度必须无限。    <br />
这里的“列表”是一个斐波那契数列。使用的迭代器如下：   </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Fibs</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
<span class="n">fibs</span><span class="o">=</span><span class="n">Fibs</span><span class="p">()</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fibs</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">f</span>
        <span class="k">break</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>13
</pre></div>
</td></tr></table>

<p>在很多情况下，__iter__被放到会在for循环中使用的对象中。  <br />
<strong>注意 正式的说法是，一个实现了__iter__方法的对象是可迭代的，一个实现了next方法的对象则是迭代器</strong>。    </p>
<p><strong><em>内建函数iter可以从可迭代的对象中获得迭代器：</em></strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-86-9cc7ef1283fa&gt; in &lt;module&gt;()
      1 a=[1,2,3]
----&gt; 2 a.next()


AttributeError: &#39;list&#39; object has no attribute &#39;next&#39;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">it</span><span class="o">=</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>1
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<p><strong><em>从迭代器中得到序列：</em></strong> <br />
使用list函数显式地将迭代器转化为列表。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">it</span><span class="o">=</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">it</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&lt;listiterator at 0x43e8978&gt;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[1, 2, 3]
</pre></div>
</td></tr></table>

<h4 id="23">2.3 类的命名空间</h4>
<p>所有位于class语句中的代码都在特殊的命名空间中执行—类命名空间。这个命名空间可由类内所有成员访问。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Class C being defined...&#39;</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Class C being defined...
</pre></div>
</td></tr></table>

<p>从上可以看出，类的定义其实就是执行代码块，这一点很有用，比如，在类的定义区并不只限使用def语句：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">MemberCounter</span><span class="p">:</span>
    <span class="n">members</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">MemberCounter</span><span class="o">.</span><span class="n">members</span><span class="o">+=</span><span class="mi">1</span>
<span class="n">m1</span><span class="o">=</span><span class="n">MemberCounter</span><span class="p">()</span>
<span class="n">m1</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">MemberCounter</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>1
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">m2</span><span class="o">=</span><span class="n">MemberCounter</span><span class="p">()</span>
<span class="n">m2</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">MemberCounter</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<p>上面的代码中，在类作用域内定义了一个可供所有成员（实例）访问的变量，用来计算类的成员数量。  <br />
就像方法一样，类作用域内的变量也可以被所有实例（对象）访问：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">m1</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">m2</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<p>那么在实例中重绑定members属性呢？</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">m1</span><span class="o">.</span><span class="n">members</span><span class="o">=</span><span class="s">&#39;Two&#39;</span>
<span class="n">m1</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&#39;Two&#39;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">m2</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>2
</pre></div>
</td></tr></table>

<h4 id="24">2.4 继承父类</h4>
<p>子类可以扩展父类的定义。将其他类名写在class语句后的圆括号内就可以继承父类：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Filter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocked</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocked</span><span class="p">]</span>
<span class="k">class</span> <span class="nc">SPAMFilter</span><span class="p">(</span><span class="n">Filter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocked</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;SPAM&#39;</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">f</span><span class="o">=</span><span class="n">Filter</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">filter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[1, 2, 3]
</pre></div>
</td></tr></table>

<p>Filter类的用处在于它可以用作其他类的父类，比如SPAMFilter类，可以将序列中“SPAM”过滤出去。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">=</span><span class="n">SPAMFilter</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">filter</span><span class="p">([</span><span class="s">&#39;SPAM&#39;</span><span class="p">,</span><span class="s">&#39;SPAM&#39;</span><span class="p">,</span><span class="s">&#39;SPAM&#39;</span><span class="p">,</span><span class="s">&#39;SPAM&#39;</span><span class="p">,</span><span class="s">&#39;eggs&#39;</span><span class="p">,</span><span class="s">&#39;bacon&#39;</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[&#39;eggs&#39;, &#39;bacon&#39;]
</pre></div>
</td></tr></table>

<p><strong>2.4.1 子类化列表，字典和字符串</strong>   <br />
如果希望实现一个和内建对象类型（例如列表，字符串和字典）行为相似的序列或映射，可以使用子类化内建类型。   <br />
注意 当子类化一个内建类型，比如list的时候，也就间接的将object子类化了。因此该类就自动成为新式类，意味着可以使用像super函数这样的特性了。    <br />
看看下面的例子-带有访问计数的列表。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">CounterList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CounterList</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span>  <span class="nb">super</span><span class="p">(</span><span class="n">CounterList</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>CounterList类严重依赖于它的子类化父类（list）的行为。CounterList类没有重写任何的方法，能直接调用列表的任何方法（如append、extend、index）。在两个被重写的方法中，super方法被用来调用相应的父类的方法，只有在__init__中添加了所需的初始化counter属性的行为，并在__getitem__中更新了counter属性。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">=</span><span class="n">CounterList</span><span class="p">(</span><span class="s">&#39;aaa&#39;</span><span class="p">)</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">=</span><span class="n">CounterList</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[1, 2, 3]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">=</span><span class="n">CounterList</span><span class="p">({</span><span class="s">&#39;first&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;second&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[&#39;second&#39;, &#39;first&#39;]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">=</span><span class="n">CounterList</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">del</span> <span class="n">c1</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
<span class="n">c1</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[9, 8, 7, 3, 2, 1, 0]
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>0
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>24
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">c1</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>3
</pre></div>
</td></tr></table>

<p>可以看到，CounterList在很多方面和列表的作用一样，但它有一个counter属性（被初始化为0），每次列表元素被访问时，它都会自增。</p>
<h4 id="25">2.5 调查继承</h4>
<p>如果想要查看一个类是否是另一个的子类，可以使用内建的issubclass函数：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">issubclass</span><span class="p">(</span><span class="n">SPAMFilter</span><span class="p">,</span><span class="n">Filter</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>True
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">issubclass</span><span class="p">(</span><span class="n">Filter</span><span class="p">,</span><span class="n">SPAMFilter</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>False
</pre></div>
</td></tr></table>

<p>如果想要知道已知类的父类(们)，可以直接使用它的特殊属性__bases__：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">SPAMFilter</span><span class="o">.</span><span class="n">__bases__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>(&lt;class __main__.Filter at 0x00000000041247C8&gt;,)
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">Filter</span><span class="o">.</span><span class="n">__bases__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>()
</pre></div>
</td></tr></table>

<p>同样，还能使用isinstance函数检测一个对象是否是一个类的实例：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">=</span><span class="n">SPAMFilter</span><span class="p">()</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">SPAMFilter</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>True
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>False
</pre></div>
</td></tr></table>

<p>如果只想知道一个对象属于哪个类，可以使用__class__属性或type函数：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">s</span><span class="o">.</span><span class="n">__class__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&lt;class __main__.SPAMFilter at 0x00000000042657C8&gt;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>__main__.SPAMFilter
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">type</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>list
</pre></div>
</td></tr></table>

<h4 id="26">2.6 多个父类</h4>
<p>一个类的父类可能多于一个，如下：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">Calculator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expression</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Talker</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">talk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;Hi,my value is &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span>
<span class="k">class</span> <span class="nc">TalkingCalculator</span><span class="p">(</span><span class="n">Calculator</span><span class="p">,</span><span class="n">Talker</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table>

<p>子类（TalkingCalculator）自己不做任何事，它从自己的父类继承所有的行为。这样它就成了会说话的计算器（talking calculator）。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">tc</span><span class="o">=</span><span class="n">TalkingCalculator</span><span class="p">()</span>
<span class="n">tc</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="s">&#39;1+2+3&#39;</span><span class="p">)</span>
<span class="n">tc</span><span class="o">.</span><span class="n">talk</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>Hi,my value is  6
</pre></div>
</td></tr></table>

<p>这种行为称为多重继承（multiple inheritance），是个非常有用的工具。   <br />
一般来说，对于对象不用探讨过深。程序员可以靠多态调用自己需要的方法。不过如果想要知道对象到底有什么方法和属性，有些函数可以帮助完成这项工作。如下可以检查对象的方法或属性是否已经存在：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">hasattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="s">&#39;talk&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>True
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">hasattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="s">&#39;fnord&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>False
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">getattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="s">&#39;talk&#39;</span><span class="p">,</span><span class="s">&#39;None&#39;</span><span class="p">)</span>   <span class="c">#获得对象属性的值，可选择提供默认值，以便在属性不存在时使用</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&lt;bound method TalkingCalculator.talk of &lt;__main__.TalkingCalculator instance at 0x0000000004379E08&gt;&gt;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">getattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="s">&#39;value&#39;</span><span class="p">,</span><span class="s">&#39;None&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>6
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">setattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="s">&#39;name&#39;</span><span class="p">,</span><span class="s">&#39;Mr. Gumby&#39;</span><span class="p">)</span>   <span class="c">#与getattr相对应的函数是setattr，用来设置对象的属性及值</span>
<span class="n">tc</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&#39;Mr. Gumby&#39;
</pre></div>
</td></tr></table>

<p>如果要查看对象内所有存储的值，那么可以使用__dict__属性。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">tc</span><span class="o">.</span><span class="n">__dict__</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>{&#39;name&#39;: &#39;Mr. Gumby&#39;, &#39;value&#39;: 6}
</pre></div>
</td></tr></table>

<h3 id="3">3 生成器</h3>
<p>生成器是Python新引入的概念。生成器是一种普遍的函数语法定义的迭代器。接下来介绍怎么创建和使用生成器，了解它的内部机制。</p>
<h4 id="31">3.1 创建生成器</h4>
<p>创建一个生成器就像创建函数一样简单。首先我们创建一个可以展开嵌套列表的函数。参数是一个列表：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">nested</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">nested</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
<span class="n">nested</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>任何包含<strong>yield语句</strong>的函数称为<strong>生成器</strong>。除了名字不同以外，它的行为和普通的函数也有很大的差别。这就在于它不像<strong>return</strong>语句那样返回值，而是每次产生一个值。每次产生一个值（使用yield语句），函数就会被冻结：即函数停在那点等待被激活。函数被激活后就从停止的那点开始执行。   <br />
接下来可以通过在生成器上迭代来使用所有的值：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">flatten</span><span class="p">(</span><span class="n">nested</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>&lt;generator object flatten at 0x00000000043F3EE8&gt;
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">nested</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">num</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="codehilite"><pre>1
2
3
4



---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-119-b385b8be1106&gt; in &lt;module&gt;()
----&gt; 1 for num in flatten(nested):
      2     print num


&lt;ipython-input-116-d7d394ff2981&gt; in flatten(nested)
      1 def flatten(nested):
      2     for sublist in nested:
----&gt; 3         for element in sublist:
      4             yield element
      5 nested=[[1,2],[3,4],5]


TypeError: &#39;int&#39; object is not iterable
</pre></div>
</td></tr></table>

<p>从上可以看到，试图对一个数值5进行迭代会引发一个TypeError异常。   <br />
生成器由两部分组成：生成器的函数和生成器的迭代器。生成器的函数是用def语句定义的，包含yield部分，生成器的迭代器是这个函数返回的部分。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="n">nested</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">]]</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">list</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">nested</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[1, 2, 3, 4, 5]
</pre></div>
</td></tr></table>

<h4 id="32">3.2 递归生成器</h4>
<p>如果要处理任意层的嵌套该怎么办？每次嵌套需要增加一个for循环，但因为不知道有几层嵌套，所以必须把解决方案变得更灵活。这就需要用到<strong>递归</strong>：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">nested</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">sublist</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">element</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">nested</span>
</pre></div>
</td></tr></table>

<p>当flatten被调用时，有两种可能性（处理递归时大部分都是这种情况）：基本情况和需要递归的情况。在基本的情况中，函数被告知展开一个元素（比如一个数字），这种情况下，for循环会引发一个TypeError异常（因为试图对一个数字进行迭代），生成器会产生一个元素。如果展开的是一个列表，那么就要进行特殊处理。程序必须遍历所有的子列表，并对他们调用flatten。然后使用另一个for循环来产生被展开的子列表的所有元素。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nb">list</span><span class="p">(</span><span class="n">flatten</span><span class="p">([[[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span><span class="mi">5</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]],</span><span class="mi">8</span><span class="p">]))</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre>[1, 2, 3, 4, 5, 6, 7, 8]
</pre></div>
</td></tr></table>

<p>到目前为止，Python语言的大部分知识都介绍了。</p>
<hr/>
标签: <span class="label label-default">python</span> <span class="label label-default">多态</span> <span class="label label-default">封装</span> <span class="label label-default">方法</span> <span class="label label-default">5</span><br/>
创建时间: 2016.11.06<br/>
上次修改: 2016.11.06
<div class="ds-thread" data-thread-key="b14494137c805dc66bdc9ed88d7fd2de" data-title="对象" data-url="http://peishunli.github.io/blog/python_beginning/5object.html"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"peishunli"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (
        document.location.protocol == 'https:' ? 'https:' : 'http:'
    ) + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
</div>

<footer class="page-footer">
  <div id="container">
    <div class="footer-left">
        <h4 class="white-text">关于peishunli.site</h4>
        <ul class="mdul">
          <li class="mdli white-text">本网站提供的内容仅用于学习和分享，不能保证内容一定正确...</li>
        </ul>
    </div>
    <div class="footer-right">
        <h4 class="white-text">其他网站链接</h4>
        <ul class="mdul">
          <li class="mdli"><a class="white-text" href="http://github.com/">Github</a></li>
		  <li class="mdli"><a class="white-text" href="http://www.zhihu.com/">知乎</a></li>
        </ul>
    </div>
  </div>
  <div class="footer-copyright">
    <div id="container">
        Copyright © 2015-2016 Powered by peishunli. All rights reserved.
    </div>
  </div>
</footer>
</body>
</html>
