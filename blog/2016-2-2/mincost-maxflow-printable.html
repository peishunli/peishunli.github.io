<!DOCTYPE html>
<html>
<head>
  <title>最小费用最大流 - riteme.site</title>
  <meta charset="UTF-8">
  <meta name="robots" content="none">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<h1 id="_1">最小费用最大流</h1>
<p>之前一直想不明白最小费用流，今天翻了很多资料才理解了，在此做点记录。</p>
<h2 id="_2">最小费用流</h2>
<p>我们首先定义流<mathjax>$f$</mathjax>的费用<mathjax>$w(f)$</mathjax>为：<br />
<mathjax>$$
w(f) = \sum_{(u,v)\in f} w(u,v)f(u,v)
$$</mathjax></p>
<p>那么最小费用（可行）流就是指一个在所有同流量的流中费用最小的流。</p>
<h2 id="_3">最小费用最大流问题</h2>
<p>在给定的流网络<mathjax>$G$</mathjax>中，若<mathjax>$(u,v)\in E$</mathjax>，则<mathjax>$c(u,v)$</mathjax>表示其容量，<mathjax>$w(u,v)$</mathjax>表示其<strong>单位流费用</strong>。设<mathjax>$f$</mathjax>为其中的可行流，最小费用最大流问题就是要求在使<mathjax>$f$</mathjax>为最大流的情况下，其总费用<mathjax>$w(f)$</mathjax>最小。</p>
<h2 id="_4">增广路算法</h2>
<p>本文中我们只讨论增广路算法。最小费用流还有消圈法和神奇的ZKW算法。</p>
<p>增广路算法有一个贪心的基本思想：已知一个最小费用流<mathjax>$f$</mathjax>，在流网络中找出一条费用最小的增广路对其增广得到<mathjax>$f^,$</mathjax>，那么<mathjax>$f^,$</mathjax>也是最小费用流。<br />
这个结论是显而易见的，因为原流费用最小，增广出来的新流费用也最小，那么总费用也是最小的。</p>
<p>因此，寻找最小费用最大流的思路就出来了：</p>
<ol>
<li>初始化零流<mathjax>$f$</mathjax>  </li>
<li>寻找费用最小的增广路，如果没有则表明<mathjax>$f$</mathjax>已为最大流  </li>
<li>增广流<mathjax>$f$</mathjax>，跳至第二步</li>
</ol>
<p>在上面的步骤中，第二步是关键。</p>
<p>我们首先要确定费用最小的衡量标准。首先考虑一条增广路会对流增加多少的费用。</p>
<p>假设<mathjax>$p$</mathjax>是一条增广路，其瓶颈边（即剩余容量最小的边）的容量为<mathjax>$c_{min}$</mathjax>，那么增加的费用就是所有边所产生的费用之和：</p>
<p><mathjax>$$w(p) = \sum_{(u,v)\in p} w(u,v)c_{min} = c_{min}\sum_{(u,v)\in p} w(u,v)$$</mathjax></p>
<p>由于我们要保证每一步都是最小费用流，而流的大小并不在意，因为最后肯定能达到最大流。<br />
故我们不在乎每次流的增量<mathjax>$c_{min}$</mathjax>，而只要使单位费用之和最小即可。</p>
<p>因此我们把每条弧的单位费用作为其边权，然后寻找一条从源点到汇点的最短路，这样就能使单位费用之和最小。</p>
<h2 id="_5">实现细节</h2>
<p>现在我们来尝试实现增广路算法，首先我们定义边的结构体：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1"># 表示有向边</span>
<span class="k">class</span> <span class="nc">DirectedEdge</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">u</span><span class="p">:</span><span class="nb">int</span>                      <span class="c1"># 出发点</span>
    <span class="n">v</span><span class="p">:</span><span class="nb">int</span>                      <span class="c1"># 进入点</span>
    <span class="n">capacity</span><span class="p">:</span><span class="nb">int</span>               <span class="c1"># 容量</span>
    <span class="n">flow</span><span class="p">:</span><span class="nb">int</span>                   <span class="c1"># 现有流量</span>
    <span class="n">cost</span><span class="p">:</span><span class="nb">int</span>                   <span class="c1"># 单位流费用</span>
    <span class="n">reverse_edge</span><span class="p">:</span><span class="n">DirectedEdge</span>  <span class="c1"># 表示其在残留网络中的反向边</span>
</pre></div>
</td></tr></table>

<p>我们添加一个函数，计算边的的剩余流量：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="n">edge</span><span class="p">:</span><span class="n">DirectedEdge</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">edge</span><span class="o">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">edge</span><span class="o">.</span><span class="n">flow</span>
</pre></div>
</td></tr></table>

<p>在残留网络中，如果剩余容量为0,它就已经不存在了。<br />
我们使<code>G</code>为一个有向边链表的数组，表示从某个点出发的边集合。</p>
<p>现在思考下残留网络中反向边的费用。反向边本意是为了最大流算法能重新调整整个流，让算法能够“反悔”，<br />
因此我们给反向边的费用为<code>-cost</code>，能够与之前的选择抵消。这样导致出现了负边，因此找最短路不能使用Dijkstra算法，</p>
<p>为了方便，我们添加一个<code>add_edge</code>函数来添加边：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="n">e</span>  <span class="o">=</span> <span class="n">DirectedEdge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>  <span class="n">cost</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>         <span class="c1"># 初始为零流</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">DirectedEdge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="o">-</span><span class="n">cost</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>  <span class="c1"># 注意是反向边</span>

    <span class="c1"># 设置反向边</span>
    <span class="n">e</span><span class="o">.</span><span class="n">reverse_edge</span> <span class="o">=</span> <span class="n">re</span>
    <span class="n">re</span><span class="o">.</span><span class="n">reverse_edge</span> <span class="o">=</span> <span class="n">e</span>

    <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>这样就可方便的添加边</p>
<p>最好采用Bellman Ford算法，这里使用其改进版SPFA算法：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">dist</span><span class="p">:</span><span class="nb">int</span><span class="p">[]</span>             <span class="o">=</span> <span class="p">[</span><span class="n">INFTY</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># 距离数组</span>
<span class="n">edge_to</span><span class="p">:</span><span class="n">DirectedEdge</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="o">...</span><span class="p">]</span>   <span class="c1"># 前趋边数组</span>

<span class="k">def</span> <span class="nf">SPFA</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="n">q</span><span class="p">:</span><span class="n">queue</span>
    <span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">q</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
        <span class="n">u</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 如果剩余容量为0,这条边就不存在</span>
                <span class="k">continue</span>

            <span class="c1"># 松弛操作</span>
            <span class="n">v</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">v</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">cost</span><span class="p">:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>    <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">cost</span>
                <span class="n">edge_to</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>  <span class="c1"># 更新前趋边</span>

                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>接下来就可以写最小费用最大流算法了：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">s</span><span class="p">:</span><span class="nb">int</span>  <span class="c1"># 源点</span>
<span class="n">t</span><span class="p">:</span><span class="nb">int</span>  <span class="c1"># 汇点</span>

<span class="k">def</span> <span class="nf">compute_maxflow</span><span class="p">():</span>
    <span class="n">answer</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">SPFA</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># 寻找增广路</span>

        <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">INFTY</span><span class="p">:</span>  <span class="c1"># 如果没有增广路，s到t的距离就不会更新</span>
            <span class="k">return</span>

        <span class="n">minflow</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="n">INFTY</span>  <span class="c1"># 瓶颈边容量</span>

        <span class="c1"># 寻找瓶颈边</span>
        <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">while</span> <span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minflow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minflow</span><span class="p">,</span> <span class="n">r</span><span class="p">(</span><span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>

        <span class="c1"># 增广</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">while</span> <span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

            <span class="n">answer</span> <span class="o">+=</span> <span class="n">minflow</span> <span class="o">*</span> <span class="n">e</span><span class="o">.</span><span class="n">cost</span>  <span class="c1"># 更新总费用</span>
            <span class="n">e</span><span class="o">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">minflow</span>
            <span class="n">e</span><span class="o">.</span><span class="n">reverse_edge</span><span class="o">.</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">minflow</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">edge_to</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>

    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</td></tr></table>

<p>至此，增广路算法就结束了。现在总结下其中涉及到的关键：<br />
1. 贪心选择：每次寻找费用最少的增广路<br />
2. 反向边边权：是相反的<br />
3. SPFA: 寻找最短路</p>
</body>
</html>
