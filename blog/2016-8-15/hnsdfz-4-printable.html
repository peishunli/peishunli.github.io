<!DOCTYPE html>
<html>
<head>
  <title>HNSDFZ2016 #4 - riteme.site</title>
  <meta charset="UTF-8">
  <meta name="robots" content="none">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<h1 id="hnsdfz2016-4">HNSDFZ2016 #4</h1>
<h2 id="a-24-ruanxingzhi">A. 24点加强版 (ruanxingzhi)</h2>
<h3 id="_1">题目描述</h3>
<p><strong>这是一道提交答案的防AK水题</strong>。</p>
<p>给定<mathjax>$n$</mathjax>个正整数,以四则运算、小括号拼出<mathjax>$k$</mathjax>。<br />
自然,每个数都要用且仅用一次。</p>
<h3 id="_2">输入格式</h3>
<p>第一行,两个正整数,表示<mathjax>$n$</mathjax>和<mathjax>$k$</mathjax>。<br />
第二行,<mathjax>$n$</mathjax>个正整数,意义如题目所述。</p>
<h3 id="_3">输出格式</h3>
<p>一行,一个四则运算的表达式。注意所有括号都是小括号,可以括号嵌套。</p>
<h3 id="1">样例输入1</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>4 24
6 6 6 6
</pre></div>
</td></tr></table>

<h3 id="1_1">样例输出1</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>()6+(6+(6)+6)
</pre></div>
</td></tr></table>

<h3 id="2">样例输入2</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>4 24
2 7 1 7
</pre></div>
</td></tr></table>

<h3 id="2_1">样例输出2</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(7*7-1)/2
</pre></div>
</td></tr></table>

<h3 id="_4">数据范围及提示</h3>
<p>对于每个输入文件<code>k_.in</code>,你需要提交一个输出文件<code>k_.out</code>.<br />
共有<mathjax>$7$</mathjax>个测试点。前<mathjax>$4$</mathjax>个测试点每个<mathjax>$10$</mathjax>分,后<mathjax>$3$</mathjax>个测试点每个<mathjax>$20$</mathjax>分。</p>
<h1 id="k-sbk-riteme"><mathjax>$k$</mathjax>-SBK变换 (riteme)</h1>
<h2 id="_5">题目描述</h2>
<p>数学家Lunk最近发现了一种逗逼的<strong>SBK变换</strong>。在Lunk眼里，SBK变换是这样的：</p>
<blockquote>
<p>给你一个<mathjax>$1$</mathjax>至<mathjax>$n$</mathjax>的排列<mathjax>$A$</mathjax>和一个<mathjax>$1$</mathjax>至<mathjax>$n$</mathjax>的排列<mathjax>$P$</mathjax>，<mathjax>$P$</mathjax>对<mathjax>$A$</mathjax>做一次SBK变换后将得到一个新的排列<mathjax>$B$</mathjax>，其中：<br />
<mathjax>$$ B_{P_i} = A_i \tag{SBK Transformation}$$</mathjax></p>
</blockquote>
<p>然而做一次SBK变换太过无聊，于是Lunk决定连续做多次SBK变换。即将每次变换后的结果<mathjax>$B$</mathjax>变为<mathjax>$A$</mathjax>，然后继续用<mathjax>$P$</mathjax>对<mathjax>$A$</mathjax>做SBK变换。Lunk想知道连续对<mathjax>$A$</mathjax>做<mathjax>$k$</mathjax>次SBK变换后的结果。</p>
<h2 id="_6">输入格式</h2>
<p>第一行输入两个整数<mathjax>$n$</mathjax>和<mathjax>$k$</mathjax>，表示排列的长度和连续做SBK变换的次数。<br />
第二行输入<mathjax>$n$</mathjax>个整数表示排列<mathjax>$A$</mathjax>。<br />
第三行输入<mathjax>$n$</mathjax>个整数表示排列<mathjax>$P$</mathjax>。</p>
<h2 id="_7">输出格式</h2>
<p>一行输出<mathjax>$n$</mathjax>个整数，表示<mathjax>$k$</mathjax>次SBK变换后的结果。</p>
<h2 id="_8">样例输入</h2>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>5 2
1 2 3 4 5
2 3 4 5 1
</pre></div>
</td></tr></table>

<h2 id="_9">样例输出</h2>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>4 5 1 2 3
</pre></div>
</td></tr></table>

<h2 id="_10">样例解释</h2>
<p>做完第一次SBK变换后： <code>5 1 2 3 4</code><br />
做完第二次SBK变换后： <code>4 5 1 2 3</code></p>
<h2 id="_11">数据范围及约定</h2>
<p>共<mathjax>$10$</mathjax>个测试点，每个测试点的数据范围如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">数据点</th>
<th align="center"><mathjax>$n$</mathjax>的规模</th>
<th align="center"><mathjax>$k$</mathjax>的规模</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center"><mathjax>$\le10^3$</mathjax></td>
<td align="center"><mathjax>$\le10^3$</mathjax></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><mathjax>$\le10^3$</mathjax></td>
<td align="center"><mathjax>$\le10^3$</mathjax></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><mathjax>$\le10^4$</mathjax></td>
<td align="center"><mathjax>$\le10^5$</mathjax></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><mathjax>$\le10^4$</mathjax></td>
<td align="center"><mathjax>$\le2\times10^5$</mathjax></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><mathjax>$\le4\times10^5$</mathjax></td>
<td align="center"><mathjax>$\le2^{30}$</mathjax></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><mathjax>$\le4\times10^5$</mathjax></td>
<td align="center"><mathjax>$\le2^{33}$</mathjax></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><mathjax>$\le6\times10^5$</mathjax></td>
<td align="center"><mathjax>$\le2^{63}$</mathjax></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><mathjax>$\le6\times10^5$</mathjax></td>
<td align="center"><mathjax>$\le2^{63}$</mathjax></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><mathjax>$\le10^6$</mathjax></td>
<td align="center"><mathjax>$\le2^{63}$</mathjax></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><mathjax>$\le2.3\times10^6$</mathjax></td>
<td align="center"><mathjax>$\le2^{63}$</mathjax></td>
</tr>
</tbody>
</table>
<h2 id="c-link">C. 稀奇古怪的根 (Link)</h2>
<h3 id="_12">题目描述</h3>
<p>DYX是一个很ZY的ZY,但是他不想ZY一样ZY。<br />
他特别喜欢捣鼓一些无与伦比的树。<br />
他也特别喜欢逆序对这种东西,因此他想把逆序对拓展到树上来。<br />
DYX对于树上的逆序对的定义是这样的:<br />
树上的某个点到根节点的路径上权值比他大的节点和他构成逆序对<br />
换句话来说,就是指,树上某个节点能和他构成逆序对的节点是他的子树中<br />
权值比他小的或者是他到根节点的路径上权值比他大的<br />
聪明的DYX很快就把他推广到树上了。<br />
最近DYX学会了LCT,里面的换根操作打动了他。<br />
因此他在想能不能把LCT的换根拓展到他的树上</p>
<p>定义树上两个节点<mathjax>$X$</mathjax>和<mathjax>$Y$</mathjax>,且<mathjax>$X$</mathjax>是<mathjax>$Y$</mathjax>到根节点的路径上面的一个节点<br />
定义<mathjax>$X$</mathjax>和<mathjax>$Y$</mathjax>构成逆序对当且仅当<mathjax>$X$</mathjax>的权值比<mathjax>$Y$</mathjax>的大<br />
给你一棵树,询问以某个节点为根的时候这棵树总共有多少组逆序对</p>
<h3 id="_13">输入格式</h3>
<p>第一行<mathjax>$n$</mathjax>和<mathjax>$m$</mathjax>表示树的节点个数和询问个数<br />
第二行<mathjax>$n$</mathjax>个数表示每个节点的权值<br />
然后<mathjax>$n-1$</mathjax>行两个数<mathjax>$X$</mathjax>,<mathjax>$Y$</mathjax>.表示点<mathjax>$X$</mathjax>和<mathjax>$Y$</mathjax>有一条边连接<br />
然后<mathjax>$m$</mathjax>行每行<mathjax>$1$</mathjax>个数<mathjax>$X$</mathjax>,表示以<mathjax>$X$</mathjax>为根的时候树中有多少组逆序对</p>
<h3 id="_14">输出格式</h3>
<p>输出<mathjax>$m$</mathjax>行,每行一个整数,表示以<mathjax>$X$</mathjax>为根的树中有多少组逆序对</p>
<h3 id="_15">样例输入</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>10 5
1 2 3 4 5 6 7 8 9 10
1 2
1 3
3 4
3 5
3 7
2 9
2 10
2 6
2 8
3
2
1
7
10
</pre></div>
</td></tr></table>

<h3 id="_16">样例输出</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>2
1
0
8
10
</pre></div>
</td></tr></table>

<h3 id="_17">数据范围及提示</h3>
<p><mathjax>$30\%$</mathjax> <mathjax>$n,\;m \le 1000$</mathjax><br />
<mathjax>$50\%$</mathjax> <mathjax>$n,\;m \le20000$</mathjax>, 且权值不大于<mathjax>$20000$</mathjax><br />
<mathjax>$100\%$</mathjax> <mathjax>$n,\;m \le 100000$</mathjax>, 保证所有数据在<code>int</code>范围内</p>
<p>提供两个类:<br />
LCT和主席树,要的请找出题人。<br />
要了的话就­1分</p>
<h2 id="d-haogram">D. 最长公共子序列 (Haogram)</h2>
<h3 id="_18">题目描述</h3>
<p>给定两个正整数序列,每个序列中元素两两不同,且范围都在<mathjax>$[1,\;n^2]$</mathjax>。求其最长公共子序列。</p>
<h3 id="_19">输入格式</h3>
<p>第一行一个正整数<mathjax>$t$</mathjax>, 表示数据组数。对于每组数据:<br />
第一行三个数<mathjax>$n$</mathjax>, <mathjax>$p$</mathjax>, <mathjax>$q$</mathjax>, <mathjax>$n$</mathjax>, 含义如题, <mathjax>$p$</mathjax>, <mathjax>$q$</mathjax>分别为两个序列的长度。<br />
接下来两行描述两个序列。</p>
<h3 id="_20">输出格式</h3>
<p>共<mathjax>$t$</mathjax>行<mathjax>$t$</mathjax>个整数,表示答案。</p>
<h3 id="_21">样例输入</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>1
3 7 8
1 7 5 4 8 3 9
1 4 3 5 6 2 8 9
</pre></div>
</td></tr></table>

<h3 id="_22">样例输出</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>4
</pre></div>
</td></tr></table>

<h3 id="_23">数据范围及提示</h3>
<p>对于<mathjax>$30\%$</mathjax>的数据，<mathjax>$n \le 30$</mathjax><br />
对于<mathjax>$100\%$</mathjax>的数据，<mathjax>$2 \le n \le 250,\;1 \lt p,\;q \le n^2,\;t\le10$</mathjax></p>
<h2 id="e-zy-hjwjbsr">E. ZY的金坷垃 (HJWJBSR)</h2>
<h3 id="_24">题目描述</h3>
<blockquote>
<p>Zy:金坷垃好处都有啥,谁说对了就给他<br />
zy:肥料掺了金坷垃,不流失,不蒸发,零浪费<br />
zY:肥料掺了金坷垃,能吸收两米下的氮磷钾<br />
zy:世界肥料都涨价,肥料掺了金坷垃,一袋能顶两袋撒<br />
zY:用了金坷垃,小麦亩产一千八。日本的粮食再也不向美国进口了!hhhhhhhh<br />
Zy:小鬼子,真不傻!金坷垃给了他对美国农业危害大,决不能给了他!<br />
Zy:非洲农业不发达,我们都要支援他。金坷垃,你们日本别想了!<br />
zY:狡猾,狡猾。没有金坷垃,怎么种庄稼!金坷垃!金坷垃!(残念脸</p>
</blockquote>
<p>zy最近从小鬼子手中抢到了金坷垃。开始考虑怎么撒。他家的地可以看做一个<mathjax>$n\times m$</mathjax>的方阵。<br />
由于非洲农业不发达,zy家的地有些地方并不能够播撒。<br />
并且金坷垃是全球瞩目的焦点是农业科技的前沿,所以播撒的方式也比较不一样:每次需要选择一个没被选择过的矩形<br />
并均匀撒上金坷垃,且必须将所有矩形都播撒一次。<br />
每次播撒的花费的金坷垃袋数是矩形包含的格子个数的平方。<br />
zy想知道他要买多少金坷垃才够用。</p>
<h3 id="_25">输入格式</h3>
<p>第一行给出两个正整数<mathjax>$n$</mathjax>和<mathjax>$m$</mathjax>代表zy家的地的长和宽。<br />
下面<mathjax>$n$</mathjax>行每行一个长度<mathjax>$m$</mathjax>的<code>01串</code>描述了zy家地的状态。<mathjax>$0$</mathjax>代表这个地不能撒,<mathjax>$1$</mathjax>代表能撒。</p>
<h3 id="_26">输出格式</h3>
<p>一个非负整数代表金坷垃至少要多少袋。</p>
<h3 id="_27">样例输入</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>5 5
01001
11000
00010
00000
10001
</pre></div>
</td></tr></table>

<h3 id="_28">样例输出</h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>15
</pre></div>
</td></tr></table>

<h3 id="_29">数据范围及提示</h3>
<p>对于<mathjax>$30\%$</mathjax>的数据, 保证<mathjax>$n,\;m \le 10$</mathjax>。<br />
对于<mathjax>$50\%$</mathjax>的数据,保证<mathjax>$n,\;m \le 100$</mathjax>。<br />
对于所有数据,保证<mathjax>$n,\;m \le 1000$</mathjax>。</p>
<h2 id="_30">题解</h2>
<h3 id="a">A</h3>
<p>这道题首先需要你有1个小时。<br />
然后就可以A掉了。<br />
防AK什么鬼......</p>
<h3 id="b">B</h3>
<ol>
<li>20分: 模拟 (<mathjax>$\Theta(nk)$</mathjax>)</li>
<li>80分:<ol>
<li>排列矩阵快速幂 (<mathjax>$\Theta(n \log k)$</mathjax>，排列矩阵的乘法可以在<mathjax>$\Theta(n)$</mathjax>的时间内计算)</li>
<li>寻找循环节，倍增找到每个值 (<mathjax>$O(n\log k)$</mathjax>)</li>
</ol>
</li>
<li>100分: 寻找循环节，取模找到每个值 (<mathjax>$\Theta(n)$</mathjax>)</li>
</ol>
<h3 id="c">C</h3>
<p>首先需要计算DFS序。<br />
然后用<strong>可持久化平衡树</strong>来维护它上面的值。<br />
首先以<mathjax>$1$</mathjax>为根，计算每棵子树中比树根小的值有多少个，加起来就是<mathjax>$1$</mathjax>的答案。<br />
然后从<mathjax>$1$</mathjax>开始DFS一遍，考虑在知道当前节点的答案的情况下，换根到自己的一个儿子处，答案的变化，可以在<mathjax>$\Theta(\log n)$</mathjax>的时间内计算出来。<br />
然后就可以愉快的<mathjax>$\Theta(1)$</mathjax>回答啦~~~</p>
<h3 id="d">D</h3>
<p>将其中一个序列的值依次重新编号，然后将另外一个序列也同步修改一下。<br />
然后就转成了求另外一个序列的最长上升子序列问题。<br />
这个可以在<mathjax>$\Theta(n\log n)$</mathjax>的时间内计算。</p>
<h3 id="e">E</h3>
<p>引用一段话：</p>
<blockquote>
<p>题解：<br />
本来打算出了另外一道题，后来才发现正确性不太好。又不想变成只能出数据结构题的选手，就临时换了这个比较裸的题。<br />
（出题好难<br />
很明显如果矩形代价都是1那么肯定就是直接悬线法。<br />
否则他要算这个的代价就在悬线法里面加特技：每次相当于要从一个长宽分别为n*m的矩形里面算满足特定条件的子矩形的答案。这样就不会重复。<br />
相当于<mathjax>$\sum_{i=y_0}^{y_1} i^2 \times \text{横着的答案}$</mathjax>。<br />
横着的答案：<mathjax>$\sum_{i=1}^m i^2 \cdot (n-i+1)$</mathjax>。<br />
然后就没了。</p>
</blockquote>
</body>
</html>
