<!DOCTYPE html>
<html>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?72d0c4a099cd676176e657b871326707";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<head>
  <title>Hall定理 - riteme.site</title>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../../favicon.png" type="image/png">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
  <script   src="https://code.jquery.com/jquery-2.2.4.min.js"   integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="   crossorigin="anonymous"></script>
  <link href="../../tipuesearch/tipuesearch.css" rel="stylesheet">
  <script src="../../tipuesearch/tipuesearch_set.js"></script>
  <script src="../../tipuesearch/tipuesearch.min.js"></script>
</head>
<body>
<div id="topbar">
  <div style="display: block; float: right">
  <form action="../../search.html">
  <input type="text" placeholder="Search Here" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
  </div>
</div>
<ul class="breadcrumb"><li><a href="../../index.html">HOME</a></li><li><a href="../../posts.html">POSTS</a></li><li><a href="../../posts.html#2016-9-19">2016-9-19</a></li><li class="active">HALL定理</li></ul>

<div id="view">
<div class="toc">
<ul>
<li><a href="#hall">Hall定理</a><ul>
<li><a href="#_1">基本形式</a></li>
<li><a href="#_2">证明</a></li>
<li><a href="#_3">简单运用</a></li>
</ul>
</li>
</ul>
</div>
<div id="container">

<h1 id="hall">Hall定理</h1>
<h2 id="_1">基本形式</h2>
<p>Hall定理是一个用于判定<strong>二分图是否具有最大匹配</strong>的定理。<br />
首先对于二分图<mathjax>$G = (X \cup Y, E)$</mathjax>，点集被分为了<mathjax>$X$</mathjax>和<mathjax>$Y$</mathjax>两部分。<br />
是否具有最大匹配，首先一个最基本的条件就是<mathjax>$|X| = |Y|$</mathjax>。<br />
Hall定理则在此基础上给出了一个更强的条件。<br />
首先对于一个点集<mathjax>$T \subseteq X$</mathjax>，定义<mathjax>$\Gamma(T)$</mathjax>如下：<br />
<mathjax>$$
\Gamma(T) = \{v \mid u \rightarrow v \in E,\; u \in T,\; v \in Y\}
$$</mathjax></p>
<p>即表示<mathjax>$T$</mathjax>中所有点能够直接到达的<mathjax>$Y$</mathjax>中的点的集合。</p>
<p><img alt="bigraph" src="http://git.oschina.net/riteme/blogimg/raw/master/hall-theorme/bigraph.png" /></p>
<p>上图中，<mathjax>$\Gamma(\{1,\;3\}) = \{4,\;5,\;6\}$</mathjax>。<br />
那么Hall条件则用于判断一个二分图是否存在最大匹配。Hall条件如下：<br />
对于<strong>任意</strong>的点集<mathjax>$T \subseteq X$</mathjax>，均存在：<br />
<mathjax>$$
|T| \le |\Gamma(T)|
$$</mathjax></p>
<p>那么此二分图必定存在最大匹配。</p>
<h2 id="_2">证明</h2>
<p>这个定理看起来很显然，证明起来也不是很难。<br />
首先我们令<mathjax>$n = |X|$</mathjax>，那么，当<mathjax>$n$</mathjax>等于<mathjax>$0$</mathjax>或<mathjax>$1$</mathjax>时，可以验证是正确的。<br />
我们尝试进行逆向归纳。对于一个<mathjax>$n &gt; 1$</mathjax>的二分图，考虑以下两种情况：</p>
<ol>
<li>如果对于任意的<mathjax>$T \subseteq X$</mathjax>均满足以下条件：<br />
<mathjax>$$ |\Gamma(T)| \ge |T| + 1 $$</mathjax><br />
那么我们可以删除图中任意一条边作为匹配。由于每个子集均满足以上条件，那么从<mathjax>$X$</mathjax>和<mathjax>$Y$</mathjax>中各删除一个点不会导致违反Hall条件，所以此操作可以使归纳继续并且使<mathjax>$n$</mathjax>减小。</li>
<li>如果存在一个<strong>最大的</strong><mathjax>$T \subset X$</mathjax>，满足以下条件：<br />
<mathjax>$$ |\Gamma(T)| = |T| $$</mathjax><br />
那么我们可以明确两点：第一，在<mathjax>$T$</mathjax>中我们可以找到一个关于<mathjax>$T$</mathjax>的最大匹配；第二，将这个匹配从图中删去，剩下的图依然满足Hall条件。因为根据Hall条件易知每一个<mathjax>$X$</mathjax>中的点必定至少与一个<mathjax>$Y$</mathjax>中的点有连边关系。同时Hall条件还表明，不存在一个不属于<mathjax>$T$</mathjax>的点，只与<mathjax>$\Gamma(T)$</mathjax>中的点有边相连。故删除它们不会造成有点的出度变为<mathjax>$0$</mathjax>，从而满足了Hall条件。</li>
</ol>
<p>因此可以通过归纳证明Hall定理。</p>
<h2 id="_3">简单运用</h2>
<p>Hall定理一般没有什么优化算法复杂度上的用途，但是可以作为一个<strong>比较好的思维工具</strong>。<br />
例如下面这个问题：<br />
<a href="http://codeforces.com/problemset/problem/720/A">[Russian Code Cup 2016 - Finals] A. Closing ceremony</a></p>
<p>大意是有一个<mathjax>$n\times m$</mathjax>的网格和<mathjax>$n \times m$</mathjax>个人，每个人都要走到一个网格上的一点，每个点只能装下一个人。<br />
同时定义两个点之间的距离为曼哈顿距离，每个人有自己行走的路程上限。<br />
现在这<mathjax>$n \times m$</mathjax>个人分成两批，从<mathjax>$(0,\;0)$</mathjax>和<mathjax>$(0,\;m+1)$</mathjax>出发，问你是否存在一种安排每个人的最终位置的方案，来满足每个人走到对应位置时的路程不超过自己的上限。</p>
<p>令点<mathjax>$A$</mathjax>为<mathjax>$(0,\;0)$</mathjax>，点<mathjax>$B$</mathjax>为<mathjax>$(0,\;m+1)$</mathjax>。并且设<mathjax>$f(i,\;j)$</mathjax>表示离<mathjax>$A$</mathjax>距离至少为<mathjax>$i$</mathjax>，离<mathjax>$B$</mathjax>距离至少为<mathjax>$j$</mathjax>的格子的个数。<br />
设<mathjax>$S_A(i)$</mathjax>表示在<mathjax>$A$</mathjax>最远距离至少为<mathjax>$i$</mathjax>的人数，同理，<mathjax>$S_B(i)$</mathjax>表示在<mathjax>$B$</mathjax>处最远距离至少为<mathjax>$i$</mathjax>的人数。由于每个人和一个位置形成了一个一一对应的关系，由此我们可以构建一个二分图，并且我们所要做的就是判定这个二分图是否具有最大匹配。<br />
事实上由于存在单调性，利用Hall定理可以知道，我们只用判定是否对于所有的<mathjax>$f(i,\;j)$</mathjax>均不大于<mathjax>$S_A(i) + S_B(j)$</mathjax>，如果满足这个条件，那么这个二分图就有最大匹配。<br />
那么现在的问题就是求得<mathjax>$f$</mathjax>。由于曼哈顿距离为<mathjax>$i$</mathjax>的等距线实际上是一条斜率为<mathjax>$1$</mathjax>或<mathjax>$-1$</mathjax>的直线，所以<mathjax>$f(i,\;j)$</mathjax>就是两条直线在网格中围成的面积。<br />
并且注意到它可以递归计算：<br />
<mathjax>$$
f(i,\;j) = f(i+1,\;j) + f(i,\;j+1) - f(i+1,\;j+1)
$$</mathjax></p>
<p>并且需要考虑这两条直线的交点是否会占用一个格子。所以我们的做法就是枚举交点，确定是那两条直线相交，并且赋给对应的<mathjax>$f$</mathjax>去，然后对<mathjax>$f$</mathjax>计算后缀和就是我们想要的东西啦～</p>
<hr/>
<a href="hall-theorem-printable.html">查看打印版本</a><br/>
标签: <span class="label label-default">图论</span> <span class="label label-default">二分图</span> <span class="label label-default">Hall定理</span><br/>
创建时间: 2016.09.19<br/>
上次修改: 2016.09.19
<div class="ds-thread" data-thread-key="b0158994982ed91db41ce1a9a89d01b0" data-title="Hall定理" data-url="http://riteme.github.io/blog/2016-9-19/hall-theorem.html"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"riteme"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (
        document.location.protocol == 'https:' ? 'https:' : 'http:'
    ) + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
</div>

<footer class="page-footer">
  <div id="container">
    <div class="footer-left">
        <h4 class="white-text">关于riteme.site</h5>
        <ul class="mdul">
          <li class="mdli white-text">一个从不乱说话的博客...</li>
        </ul>
    </div>
    <div class="footer-right">
        <h4 class="white-text">友情链接</h5>
        <ul class="mdul">
          <li class="mdli"><a class="white-text" href="http://link-arthur.github.io/"><del>LinkSBK</del></a></li>
          <li class="mdli"><a class="white-text" href="http://ruanxingzhi.github.io/">ruanxingzhi</a></li>
          <li class="mdli"><a class="white-text" href="http://haogram.hol.es/">核糖核酸</a></li>
          <li class="mdli"><a class="white-text" href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a></li>
        </ul>
    </div>
  </div>
  <div class="footer-copyright">
    <div id="container">
        Copyright © 2015-2016 riteme. All rights reserved.
    </div>
  </div>
</footer>
</body>
</html>
