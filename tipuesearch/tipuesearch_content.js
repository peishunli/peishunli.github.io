var tipuesearch = {"pages": [{"title": "All Posts","text": "<br />所有文章<br />Python beginning<br /><br /><br />基础知识<br /><br /><br />数据结构<br /><br /><br />条件和循环语句<br /><br /><br />函数<br /><br /><br />对象<br /><br /><br />模块<br /><br /><br />NumPy-快速处理数据<br /><br /><br />SciPy-数值计算库<br /><br /><br />matplotlib-绘制精美的图表<br /><br /><br />Matlab<br />Linux","tags": "Posts","url": "blog/posts.html"},
{"title": "Home Page","text": "本网站内容大多是关于生物信息和编程，大家随意翻阅，更新比较缓慢<br />最近文章<br />matplotlib介绍了用matplotlib绘制精美的图表Read More…<br />SciPy介绍了用SciPy进行数值计算Read More…<br />NumPy介绍了用NumPy快速处理数据Read More…<br />模块介绍了python的模块Read More…<br />查看全部…<br />–>意见箱<–","tags": "Home","url": "index.html"},
{"title": "NumPy-快速处理数据","text": "<br />标准安装的Python中用列表(list)保存一组值，可以用来当作数组使用，不过由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的[1,2,3]，需要有3个指针和三个整数对象。对于数值运算来说这种结构显然比较浪费内存和CPU计算时间。 <br />此外Python还提供了一个array模块，array对象和列表不同，它直接保存数值，和C语言的一维数组比较类似。但是由于它不支持多维，也没有各种运算函数，因此也不适合做数值运算。 <br />NumPy的诞生弥补了这些不足，NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray(下文统一称之为数组)是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。   <br />1 ndarray对象<br />1.1 创建<br />首先需要创建数组才能对其进行其它操作。  <br />我们可以通过给array函数传递Python的序列对象创建数组，如果传递的是多层嵌套的序列，将创建多维数组(下例中的变量c):<br />1<br />2<br />3<br />4import numpy as np<br />a = np.array([1, 2, 3, 4])<br />c = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])<br />c<br /><br /><br />1<br />2<br />3array([[ 1,  2,  3,  4],<br />       [ 4,  5,  6,  7],<br />       [ 7,  8,  9, 10]])<br /><br /><br />数组的大小可以通过其shape属性获得：<br />1c.shape<br /><br /><br />1(3L, 4L)<br /><br /><br />使用数组的reshape方法，可以创建一个改变了尺寸的新数组，原数组的shape保持不变：<br />1<br />2d = a.reshape((2,2))<br />d<br /><br /><br />1<br />2array([[1, 2],<br />       [3, 4]])<br /><br /><br />1a<br /><br /><br />1array([1, 2, 3, 4])<br /><br /><br />数组a和d其实共享数据存储内存区域，因此修改其中任意一个数组的元素都会同时修改另外一个数组的内容：<br />1<br />2a[1] = 100<br />d<br /><br /><br />1<br />2array([[  1, 100],<br />       [  3,   4]])<br /><br /><br />数组的元素类型可以通过dtype属性获得。上面例子中的参数序列的元素都是整数，因此所创建的数组的元素类型也是整数，并且是32bit的长整型。可以通过dtype参数在创建时指定元素类型:<br />1a.dtype<br /><br /><br />1dtype('int32')<br /><br /><br />1<br />2b=np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]], dtype=np.float)<br />b<br /><br /><br />1<br />2<br />3array([[  1.,   2.,   3.,   4.],<br />       [  4.,   5.,   6.,   7.],<br />       [  7.,   8.,   9.,  10.]])<br /><br /><br />上面的例子都是先创建一个Python序列，然后通过array函数将其转换为数组，这样做显然效率不高。因此NumPy提供了很多专门用来创建数组的函数。下面的每个函数都有一些关键字参数，具体用法请查看函数说明。  <br />+ arange函数类似于python的range函数，通过指定开始值、终值和步长来创建一维数组，注意数组不包括终值:<br />1np.arange(0, 1, 0.1)<br /><br /><br />1array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])<br /><br /><br /><br />linspace函数通过指定开始值、终值和元素个数来创建一维数组，可以通过endpoint关键字指定是否包括终值，缺省设置是包括终值:<br /><br />1np.linspace(0, 1, 12)<br /><br /><br />1<br />2<br />3array([ 0.        ,  0.09090909,  0.18181818,  0.27272727,  0.36363636,<br />        0.45454545,  0.54545455,  0.63636364,  0.72727273,  0.81818182,<br />        0.90909091,  1.        ])<br /><br /><br /><br />logspace函数和linspace类似，不过它创建等比数列，下面的例子产生1(10^0)到100(10^2)、有20个元素的等比数列:<br /><br />1 np.logspace(0, 2, 20)<br /><br /><br />1<br />2<br />3<br />4<br />5array([   1.        ,    1.27427499,    1.62377674,    2.06913808,<br />          2.6366509 ,    3.35981829,    4.2813324 ,    5.45559478,<br />          6.95192796,    8.8586679 ,   11.28837892,   14.38449888,<br />         18.32980711,   23.35721469,   29.76351442,   37.92690191,<br />         48.32930239,   61.58482111,   78.47599704,  100.        ])<br /><br /><br />1.2 存取元素<br />数组元素的存取方法和Python的标准方法相同：<br />1<br />2a = np.arange(10)<br />a[5]<br /><br /><br />15<br /><br /><br />1a[:5]   # 省略开始下标，表示从a[0]开始<br /><br /><br />1array([0, 1, 2, 3, 4])<br /><br /><br />和Python的列表序列不同，通过下标范围获取的新的数组是原始数组的一个视图。它与原始数组共享同一块数据空间：<br />1<br />2b = a[3:7]<br />b<br /><br /><br />1array([3, 4, 5, 6])<br /><br /><br />1<br />2b[2] = -10 # 将b的第2个元素修改为-10<br />a   # a的第5个元素也被修改为-10<br /><br /><br />1array([  0,   1,   2,   3,   4, -10,   6,   7,   8,   9])<br /><br /><br />1.3 多维数组<br />多维数组的存取和一维数组类似，因为多维数组有多个轴，因此它的下标需要用多个值来表示，NumPy采用元组(tuple)作为数组的下标。<br />1<br />2a= np.arange(0, 60, 10).reshape(-1, 1)+ np.arange(0, 6)<br />a<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6array([[ 0,  1,  2,  3,  4,  5],<br />       [10, 11, 12, 13, 14, 15],<br />       [20, 21, 22, 23, 24, 25],<br />       [30, 31, 32, 33, 34, 35],<br />       [40, 41, 42, 43, 44, 45],<br />       [50, 51, 52, 53, 54, 55]])<br /><br /><br />用于存取数组的下标和仍然是一个有两个元素的元组，元组中的每个元素都是整数序列，分别对应数组的第0轴和第1轴。从两个序列的对应位置取出两个整数组成下标： a[0,1], a[1,2], …, a[4,5]。<br />1a[(0,1,2,3,4),(1,2,3,4,5)]<br /><br /><br />1array([ 1, 12, 23, 34, 45])<br /><br /><br />2 ufunc运算<br />ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。NumPy内置的许多ufunc函数都是在C语言级别实现的，因此它们的计算速度非常快。让我们来看一个例子：<br />1<br />2x = np.linspace(0, 2*np.pi, 10)<br />x<br /><br /><br />1<br />2array([ 0.        ,  0.6981317 ,  1.3962634 ,  2.0943951 ,  2.7925268 ,<br />        3.4906585 ,  4.1887902 ,  4.88692191,  5.58505361,  6.28318531])<br /><br /><br />1<br />2y = np.sin(x)   # 对数组x中的每个元素进行正弦计算，返回一个同样大小的新数组<br />y<br /><br /><br />1<br />2<br />3<br />4array([  0.00000000e+00,   6.42787610e-01,   9.84807753e-01,<br />         8.66025404e-01,   3.42020143e-01,  -3.42020143e-01,<br />        -8.66025404e-01,  -9.84807753e-01,  -6.42787610e-01,<br />        -2.44929360e-16])<br /><br /><br />我用下面这个小程序，比较了一下numpy.math和Python标准库的math.sin的计算速度：:<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19import time<br />import math<br />import numpy as np<br /><br />x = [i * 0.001 for i in xrange(1000000)]<br />start = time.clock()<br />for i, t in enumerate(x):<br />    x[i] = math.sin(t)<br />print \"math.sin:\", time.clock() - start<br /><br />x = [i * 0.001 for i in xrange(1000000)]<br />x = np.array(x)<br />start = time.clock()<br />np.sin(x,x)<br />print \"numpy.sin:\", time.clock() - start<br /><br /># 输出<br /># math.sin: 1.15426932753<br /># numpy.sin: 0.0882399858083<br /><br /><br />1<br />2math.sin: 0.387826021987<br />numpy.sin: 0.0187235443572<br /><br /><br />通过上面的例子我们了解了如何最有效率地使用math库和numpy库中的数学函数。因为它们各有长短，因此在导入时不建议使用*号全部载入，而是应该使用import numpy as np的方式载入，这样我们可以根据需要选择合适的函数调用。<br />3 文件存取<br />NumPy提供了多种文件操作函数方便我们存取数组内容。文件存取的格式分为两类：二进制和文本。而二进制格式的文件又分为NumPy专用的格式化二进制类型和无格式类型。 <br />使用numpy.savetxt和numpy.loadtxt可以读写1维和2维的数组：<br />1<br />2<br />3a = np.arange(0,12,0.5).reshape(4,-1)<br />np.savetxt(\"a.txt\", a) # 缺省按照'% .18e'格式保存数据，以空格分隔<br />np.loadtxt(\"a.txt\")<br /><br /><br />1<br />2<br />3<br />4array([[  0. ,   0.5,   1. ,   1.5,   2. ,   2.5],<br />       [  3. ,   3.5,   4. ,   4.5,   5. ,   5.5],<br />       [  6. ,   6.5,   7. ,   7.5,   8. ,   8.5],<br />       [  9. ,   9.5,  10. ,  10.5,  11. ,  11.5]])<br /><br /><br />1<br />2np.savetxt(\"a.txt\", a, fmt=\"% d\", delimiter=\",\") #改为保存为整数，以逗号分隔<br />np.loadtxt(\"a.txt\",delimiter=\",\") # 读入的时候也需要指定逗号分隔<br /><br /><br />1<br />2<br />3<br />4array([[  0.,   0.,   1.,   1.,   2.,   2.],<br />       [  3.,   3.,   4.,   4.,   5.,   5.],<br />       [  6.,   6.,   7.,   7.,   8.,   8.],<br />       [  9.,   9.,  10.,  10.,  11.,  11.]])<br /><br /><br />1<br /><br />","tags": "python ndarray ufunc 7","url": "blog/python_beginning/7numpy.html"},
{"title": "SciPy-数值计算库","text": "<br />SciPy函数库在NumPy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵等等。由于其涉及的领域众多、本书没有能力对其一一的进行介绍。<br />1 最小二乘拟合<br />假设有一组实验数据(x[i], y[i])，我们知道它们之间的函数关系:y = f(x)，通过这些已知信息，需要确定函数中的一些参数项。例如，如果f是一个线型函数f(x) = k*x+b，那么参数k和b就是我们需要确定的值。<br />scipy中的子函数库optimize已经提供了实现最小二乘拟合(Least-square fitting)算法的函数leastsq。下面是用leastsq进行数据拟合的一个例子：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39# -*- coding: utf-8 -*-<br />import numpy as np<br />from scipy.optimize import leastsq<br />import pylab as pl<br /><br />def func(x, p):<br />    \"\"\"<br />    数据拟合所用的函数: A*sin(2*pi*k*x + theta)<br />    \"\"\"<br />    A, k, theta = p<br />    return A*np.sin(2*np.pi*k*x+theta)   <br /><br />def residuals(p, y, x):<br />    \"\"\"<br />    实验数据x, y和拟合函数之间的差，p为拟合需要找到的系数<br />    \"\"\"<br />    return y - func(x, p)<br /><br />x = np.linspace(0, -2*np.pi, 100)<br />A, k, theta = 10, 0.34, np.pi/6 # 真实数据的函数参数<br />y0 = func(x, [A, k, theta]) # 真实数据<br />y1 = y0 + 2 * np.random.randn(len(x)) # 加入噪声之后的实验数据    <br /><br />p0 = [7, 0.2, 0] # 第一次猜测的函数拟合参数<br /><br /># 调用leastsq进行数据拟合<br /># residuals为计算误差的函数<br /># p0为拟合参数的初始值<br /># args为需要拟合的实验数据<br />plsq = leastsq(residuals, p0, args=(y1, x))<br /><br />print u\"真实参数:\", [A, k, theta] <br />print u\"拟合参数\", plsq[0] # 实验数据拟合后的参数<br /><br />pl.plot(x, y0, label=u\"真实数据\")<br />pl.plot(x, y1, label=u\"带噪声的实验数据\")<br />pl.plot(x, func(x, plsq[0]), label=u\"拟合数据\")<br />pl.legend()<br />pl.show()<br /><br /><br />1<br />2真实参数: [10, 0.34, 0.5235987755982988]<br />拟合参数 [ 10.09912902   0.3412268   -5.70118097]<br /><br /><br />这个例子中我们要拟合的函数是一个正弦波函数，它有三个参数 A, k, theta ，分别对应振幅、频率、相角。假设我们的实验数据是一组包含噪声的数据 x, y1，其中y1是在真实数据y0的基础上加入噪声的到了。 <br />通过leastsq函数对带噪声的实验数据x, y1进行数据拟合，可以找到x和真实数据y0之间的正弦关系的三个参数： A, k, theta。上面是程序的输出：  <br />我们看到拟合参数虽然和真实参数完全不同，但是由于正弦函数具有周期性，实际上拟合参数得到的函数和真实参数对应的函数是一致的。<br />2 非线性方程组求解<br />optimize库中的fsolve函数可以用来对非线性方程组进行求解。它的基本调用形式如下：  <br />fsolve(func, x0)   <br />func(x)是计算方程组误差的函数，它的参数x是一个矢量，表示方程组的各个未知数的一组可能解，func返回将x代入方程组之后得到的误差；x0为未知数矢量的初始值。如果要对如下方程组进行求解的话：  <br />f1(u1,u2,u3) = 0 <br />f2(u1,u2,u3) = 0 <br />f3(u1,u2,u3) = 0 <br />那么func可以如下定义：     <br />1<br />2<br />3def func(x):     <br />    u1,u2,u3 = x   <br />    return [f1(u1,u2,u3), f2(u1,u2,u3), f3(u1,u2,u3)] <br /><br /><br />下面是一个实际的例子，求解如下方程组的解：   <br />5*x1 + 3 = 0  <br />4*x0*x0 - 2*sin(x1*x2) = 0  <br />x1*x2 - 1.5 = 0  <br />程序如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17from scipy.optimize import fsolve<br />from math import sin,cos<br /><br />def f(x):<br />    x0 = float(x[0])<br />    x1 = float(x[1])<br />    x2 = float(x[2])<br />    return [<br />        5*x1+3,<br />        4*x0*x0 - 2*sin(x1*x2),<br />        x1*x2 - 1.5<br />    ]<br /><br />result = fsolve(f, [1,1,1])<br /><br />print result<br />print f(result)<br /><br /><br />1<br />2[-0.70622057 -0.6        -2.5       ]<br />[0.0, -9.126033262418787e-14, 5.329070518200751e-15]<br /><br /><br />由于fsolve函数在调用函数f时，传递的参数为数组，因此如果直接使用数组中的元素计算的话，计算速度将会有所降低，因此这里先用float函数将数组中的元素转换为Python中的标准浮点数，然后调用标准math库中的函数进行运算。<br />3 数值积分<br />数值积分是对定积分的数值求解，例如可以利用数值积分计算某个形状的面积。下面让我们来考虑一下如何计算半径为1的半圆的面积，根据圆的面积公式，其面积应该等于PI/2。单位半圆曲线可以用下面的函数表示：<br />1<br />2def half_circle(x):<br />    return (1-x**2)**0.5<br /><br /><br />调用scipy.integrate库中的quad函数的话，将会得到非常精确的结果：<br />1<br />2<br />3from scipy import integrate<br />pi_half, err = integrate.quad(half_circle, -1, 1)<br />pi_half*2<br /><br /><br />13.141592653589797<br /><br /><br />4 解常微分方程组<br />scipy.integrate库提供了常微分方程组求解算法odeint。下面让我们来看看如何用odeint计算洛仑兹吸引子的轨迹。洛仑兹吸引子由下面的三个微分方程定义：<br />这三个方程定义了三维空间中各个坐标点上的速度矢量。从某个坐标开始沿着速度矢量进行积分，就可以计算出无质量点在此空间中的运动轨迹。其中 \\sigma, \\rho, \\beta 为三个常数，不同的参数可以计算出不同的运动轨迹： x(t), y(t), z(t)。 当参数为某些值时，轨迹出现馄饨现象：即微小的初值差别也会显著地影响运动轨迹。下面是洛仑兹吸引子的轨迹计算和绘制程序：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24from scipy.integrate import odeint <br />import numpy as np <br /><br />def lorenz(w, t, p, r, b): <br />    # 给出位置矢量w，和三个参数p, r, b计算出<br />    # dx/dt, dy/dt, dz/dt的值<br />    x, y, z = w<br />    # 直接与lorenz的计算公式对应 <br />    return np.array([p*(y-x), x*(r-z)-y, x*y-b*z]) <br /><br />t = np.arange(0, 30, 0.01) # 创建时间点 <br /># 调用ode对lorenz进行求解, 用两个不同的初始值 <br />track1 = odeint(lorenz, (0.0, 1.00, 0.0), t, args=(10.0, 28.0, 3.0)) <br />track2 = odeint(lorenz, (0.0, 1.01, 0.0), t, args=(10.0, 28.0, 3.0)) <br /><br /># 绘图<br />from mpl_toolkits.mplot3d import Axes3D<br />import matplotlib.pyplot as plt <br /><br />fig = plt.figure()<br />ax = Axes3D(fig)<br />ax.plot(track1[:,0], track1[:,1], track1[:,2])<br />ax.plot(track2[:,0], track2[:,1], track2[:,2])<br />plt.show()<br /><br /><br />1<br /><br />","tags": "python 最小二乘拟合 数值积分 8","url": "blog/python_beginning/8scipy.html"},
{"title": "matplotlib-绘制精美的图表","text": "<br />matplotlib 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。  <br />它的文档相当完备，并且Gallery页面中有上百幅缩略图，打开之后都有源程序。因此如果你需要绘制某种类型的图，只需要在这个页面中浏览/复制/粘贴一下，基本上都能搞定。 <br />本章节作为matplotlib的入门介绍，将较为深入地挖掘几个例子，从中理解和学习matplotlib绘图的一些基本概念。<br />1 快速绘图<br />matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。让我们先来看一个简单的例子：<br />1<br />2<br />3% matplotlib inline<br />import matplotlib.pyplot as plt<br />import numpy as np<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16# -*- coding: utf-8 -*-<br />x = np.linspace(0, 10, 1000)<br />y = np.sin(x)<br />z = np.cos(x**2)<br />plt.figure(figsize=(8,4))   #调用figure创建一个Figure绘图对象，并且使它成为当前的绘图对象<br />plt.plot(x,y,label=\"$sin(x)$\",color=\"red\",linewidth=2)  #调用plot函数在当前的绘图对象中进行绘图<br />plt.plot(x,z,\"b--\",label=\"$cos(x^2)$\")<br />#通过一系列函数设置绘图对象的各个属性<br />plt.xlabel(\"Time(s)\")<br />plt.ylabel(\"Volt\")<br />plt.title(\"PyPlot First Example\")<br />plt.ylim(-1.2,1.2)<br />plt.legend()<br />plt.savefig(\"test1.png\")    #图像的大小是576*288像素,默认dpi为72<br />#plt.savefig(\"test2.png\",dpi=80)<br />plt.show()  #显示出我们创建的所有绘图对象<br /><br /><br /><br />pylab模块<br />matplotlib还提供了名为pylab的模块，其中包括了许多numpy和pyplot中常用的函数，方便用户快速进行计算和绘图，可以用于IPython中的快速交互式使用。<br />通过figsize参数可以指定绘图对象的宽度和高度，单位为英寸；dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80。因此本例中所创建的图表窗口的宽度为8*80 = 640像素。  <br />但是用工具栏中的保存按钮保存下来的png图像的大小是800*400像素。这是因为保存图表用的函数savefig使用不同的DPI配置，savefig函数也有一个dpi参数，如果不设置的话，将使用matplotlib配置文件中的配置，此配置可以通过如下语句进行查看，关于配置文件将在后面的章节进行介绍：<br />1<br />2import matplotlib<br />matplotlib.rcParams[\"savefig.dpi\"]<br /><br /><br />172.0<br /><br /><br />plot函数的调用方式很灵活，第一句将x,y数组传递给plot之后，用关键字参数指定各种属性：  <br /> label : 给所绘制的曲线一个名字，此名字在图示(legend)中显示。只要在字符串前后添加”$”符号，matplotlib就会使用其内嵌的latex引擎绘制的数学公式。<br /> color : 指定曲线的颜色<br />* linewidth : 指定曲线的宽度<br />2 配置属性<br />matplotlib所绘制的图的每个组成部分都对应有一个对象，我们可以通过调用这些对象的属性设置方法set_*或者pyplot的属性设置函数setp设置其属性值。例如plot函数返回一个 matplotlib.lines.Line2D 对象的列表，下面的例子显示如何设置Line2D对象的属性：<br />1<br />2<br />3<br />4x = np.arange(0, 5, 0.1)<br />line = plt.plot(x, x*x) # plot返回含有一个Line2D对象的列表<br /># 调用Line2D对象的set_*方法设置属性值<br />line[0].set_antialiased(False)  #通过line[0]获取其第一个元素（Line2D对象）<br /><br /><br /><br />1<br />2<br />3<br />4# 同时绘制sin和cos两条曲线，lines是一个有两个Line2D对象的列表<br />lines = plt.plot(x, np.sin(x), x, np.cos(x))<br /># 调用setp函数同时配置多个Line2D对象的多个属性值<br />plt.setp(lines, color=\"r\", linewidth=2.0)<br /><br /><br />1[None, None, None, None]<br /><br /><br /><br />1lines<br /><br /><br />1<br />2[<matplotlib.lines.Line2D at 0x10ab36d8>,<br /> <matplotlib.lines.Line2D at 0x10ab3470>]<br /><br /><br />同样我们可以通过调用Line2D对象的get_*方法，或者plt.getp函数获取对象的属性值：<br />1line[0].get_linewidth()  #调用Line2D对象的get_*方法<br /><br /><br />11.0<br /><br /><br />1plt.getp(lines[0], \"color\")  #plt.getp函数获取对象的属性值,返回color属性<br /><br /><br />1'r'<br /><br /><br />1plt.getp(lines[1]) # 输出全部属性<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45    agg_filter = None<br />    alpha = None<br />    animated = False<br />    antialiased or aa = True<br />    axes = Axes(0.125,0.125;0.775x0.775)<br />    children = []<br />    clip_box = TransformedBbox(Bbox([[0.0, 0.0], [1.0, 1.0]]), Co...<br />    clip_on = True<br />    clip_path = None<br />    color or c = r<br />    contains = None<br />    dash_capstyle = butt<br />    dash_joinstyle = round<br />    data = (array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6, ...<br />    drawstyle = default<br />    figure = Figure(480x320)<br />    fillstyle = full<br />    gid = None<br />    label = _line1<br />    linestyle or ls = -<br />    linewidth or lw = 2.0<br />    marker = None<br />    markeredgecolor or mec = r<br />    markeredgewidth or mew = 0.5<br />    markerfacecolor or mfc = r<br />    markerfacecoloralt or mfcalt = none<br />    markersize or ms = 6.0<br />    markevery = None<br />    path = Path(array([[ 0.        ,  1.        ],        [ 0...<br />    path_effects = []<br />    picker = None<br />    pickradius = 5<br />    rasterized = None<br />    sketch_params = None<br />    snap = None<br />    solid_capstyle = projecting<br />    solid_joinstyle = round<br />    transform = CompositeGenericTransform(TransformWrapper(Blended...<br />    transformed_clip_path_and_affine = (None, None)<br />    url = None<br />    visible = True<br />    xdata = [ 0.   0.1  0.2  0.3  0.4  0.5]...<br />    xydata = [[ 0.          1.        ]  [ 0.1         0.995004...<br />    ydata = [ 1.          0.99500417  0.98006658  0.95533649  ...<br />    zorder = 2<br /><br /><br />注意getp函数只能对一个对象进行操作，它有两种用法：<br /><br />指定属性名：返回对象的指定属性的值<br />不指定属性名：打印出对象的所有属性和其值     <br /><br />matplotlib的整个图表为一个Figure对象，此对象在调用plt.figure函数时返回，我们也可以通过plt.gcf函数获取当前的绘图对象：<br />1<br />2f = plt.gcf()<br />plt.getp(f)<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36    agg_filter = None<br />    alpha = None<br />    animated = False<br />    axes = []<br />    children = [<matplotlib.patches.Rectangle object at 0x0000000...<br />    clip_box = None<br />    clip_on = True<br />    clip_path = None<br />    contains = None<br />    default_bbox_extra_artists = []<br />    dpi = 80.0<br />    edgecolor = (1, 1, 1, 0)<br />    facecolor = (1, 1, 1, 0)<br />    figheight = 4.0<br />    figure = None<br />    figwidth = 6.0<br />    frameon = True<br />    gid = None<br />    label = <br />    path_effects = []<br />    picker = None<br />    rasterized = None<br />    size_inches = [ 6.  4.]<br />    sketch_params = None<br />    snap = None<br />    tight_layout = False<br />    transform = IdentityTransform()<br />    transformed_clip_path_and_affine = (None, None)<br />    url = None<br />    visible = True<br />    window_extent = TransformedBbox(Bbox([[0.0, 0.0], [6.0, 4.0]]), Af...<br />    zorder = 0<br /><br /><br /><br /><matplotlib.figure.Figure at 0x126bbe80><br /><br /><br />Figure对象有一个axes属性，其值为AxesSubplot对象的列表，每个AxesSubplot对象代表图表中的一个子图，前面所绘制的图表只包含一个子图，当前子图也可以通过plt.gca获得  <br />用plt.getp可以发现AxesSubplot对象有很多属性，例如它的lines属性为此子图所包括的 Line2D 对象列表：<br />1<br />2alllines = plt.getp(plt.gca(), \"lines\")<br />alllines<br /><br /><br />1<a list of 0 Line2D objects><br /><br /><br /><br />1plt.getp(plt.gca())<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54<br />55<br />56<br />57<br />58<br />59<br />60<br />61<br />62<br />63<br />64<br />65<br />66<br />67<br />68<br />69<br />70<br />71<br />72<br />73<br />74    adjustable = box<br />    agg_filter = None<br />    alpha = None<br />    anchor = C<br />    animated = False<br />    aspect = auto<br />    autoscale_on = True<br />    autoscalex_on = True<br />    autoscaley_on = True<br />    axes = Axes(0.125,0.125;0.775x0.775)<br />    axes_locator = None<br />    axis_bgcolor = w<br />    axisbelow = False<br />    children = [<matplotlib.spines.Spine object at 0x00000000116A...<br />    clip_box = None<br />    clip_on = True<br />    clip_path = None<br />    contains = None<br />    cursor_props = (1, (0.0, 0.0, 0.0, 1.0))<br />    data_ratio = 1.0<br />    default_bbox_extra_artists = [<matplotlib.spines.Spine object at 0x00000000116A...<br />    figure = Figure(480x320)<br />    frame_on = True<br />    geometry = (1, 1, 1)<br />    gid = None<br />    images = <a list of 0 AxesImage objects><br />    label = <br />    legend = None<br />    legend_handles_labels = ([], [])<br />    lines = <a list of 0 Line2D objects><br />    navigate = True<br />    navigate_mode = None<br />    path_effects = []<br />    picker = None<br />    position = Bbox(x0=0.125, y0=0.125, x1=0.9, y1=0.9)<br />    rasterization_zorder = None<br />    rasterized = None<br />    renderer_cache = None<br />    shared_x_axes = <matplotlib.cbook.Grouper object at 0x000000000AEB...<br />    shared_y_axes = <matplotlib.cbook.Grouper object at 0x000000000AEB...<br />    sketch_params = None<br />    snap = None<br />    subplotspec = <matplotlib.gridspec.SubplotSpec object at 0x00000...<br />    title = <br />    transform = IdentityTransform()<br />    transformed_clip_path_and_affine = (None, None)<br />    url = None<br />    visible = True<br />    window_extent = TransformedBbox(Bbox([[0.125, 0.125], [0.9, 0.9]])...<br />    xaxis = XAxis(60.000000,40.000000)<br />    xaxis_transform = BlendedGenericTransform(CompositeGenericTransform(...<br />    xbound = (0.0, 1.0)<br />    xgridlines = <a list of 6 Line2D xgridline objects><br />    xlabel = <br />    xlim = (0.0, 1.0)<br />    xmajorticklabels = <a list of 6 Text xticklabel objects><br />    xminorticklabels = <a list of 0 Text xticklabel objects><br />    xscale = linear<br />    xticklabels = <a list of 6 Text xticklabel objects><br />    xticklines = <a list of 12 Text xtickline objects><br />    xticks = [ 0.   0.2  0.4  0.6  0.8  1. ]<br />    yaxis = YAxis(60.000000,40.000000)<br />    yaxis_transform = BlendedGenericTransform(BboxTransformTo(Transforme...<br />    ybound = (0.0, 1.0)<br />    ygridlines = <a list of 6 Line2D ygridline objects><br />    ylabel = <br />    ylim = (0.0, 1.0)<br />    ymajorticklabels = <a list of 6 Text yticklabel objects><br />    yminorticklabels = <a list of 0 Text yticklabel objects><br />    yscale = linear<br />    yticklabels = <a list of 6 Text yticklabel objects><br />    yticklines = <a list of 12 Line2D ytickline objects><br />    yticks = [ 0.   0.2  0.4  0.6  0.8  1. ]<br />    zorder = 0<br /><br /><br /><br />3 配置文件<br />一幅图有许多需要配置的属性，例如颜色、字体、线型等等。我们在绘图时，并没有一一对这些属性进行配置，许多都直接采用了Matplotlib的缺省配置。Matplotlib将缺省配置保存在一个文件中，通过更改这个文件，我们可以修改这些属性的缺省值。 <br />通过下面的语句可以获得目前使用的配置文件的路径：<br />import matplotlib<br />matplotlib.matplotlib_fname()<br />如果你用文本编辑器打开此配置文件的话，你会发现它实际上是定义了一个字典。为了对众多的配置进行区分，关键字可以用点分开。<br />配置文件的读入可以使用 rc_params 函数，它返回一个配置字典：<br />1matplotlib.rc_params()<br /><br /><br />  1<br />  2<br />  3<br />  4<br />  5<br />  6<br />  7<br />  8<br />  9<br /> 10<br /> 11<br /> 12<br /> 13<br /> 14<br /> 15<br /> 16<br /> 17<br /> 18<br /> 19<br /> 20<br /> 21<br /> 22<br /> 23<br /> 24<br /> 25<br /> 26<br /> 27<br /> 28<br /> 29<br /> 30<br /> 31<br /> 32<br /> 33<br /> 34<br /> 35<br /> 36<br /> 37<br /> 38<br /> 39<br /> 40<br /> 41<br /> 42<br /> 43<br /> 44<br /> 45<br /> 46<br /> 47<br /> 48<br /> 49<br /> 50<br /> 51<br /> 52<br /> 53<br /> 54<br /> 55<br /> 56<br /> 57<br /> 58<br /> 59<br /> 60<br /> 61<br /> 62<br /> 63<br /> 64<br /> 65<br /> 66<br /> 67<br /> 68<br /> 69<br /> 70<br /> 71<br /> 72<br /> 73<br /> 74<br /> 75<br /> 76<br /> 77<br /> 78<br /> 79<br /> 80<br /> 81<br /> 82<br /> 83<br /> 84<br /> 85<br /> 86<br /> 87<br /> 88<br /> 89<br /> 90<br /> 91<br /> 92<br /> 93<br /> 94<br /> 95<br /> 96<br /> 97<br /> 98<br /> 99<br />100<br />101<br />102<br />103<br />104<br />105<br />106<br />107<br />108<br />109<br />110<br />111<br />112<br />113<br />114<br />115<br />116<br />117<br />118<br />119<br />120<br />121<br />122<br />123<br />124<br />125<br />126<br />127<br />128<br />129<br />130<br />131<br />132<br />133<br />134<br />135<br />136<br />137<br />138<br />139<br />140<br />141<br />142<br />143<br />144<br />145<br />146<br />147<br />148<br />149<br />150<br />151<br />152<br />153<br />154<br />155<br />156<br />157<br />158<br />159<br />160<br />161<br />162<br />163<br />164<br />165<br />166<br />167<br />168<br />169<br />170<br />171<br />172<br />173<br />174<br />175<br />176<br />177<br />178<br />179<br />180<br />181<br />182<br />183<br />184<br />185<br />186<br />187<br />188<br />189<br />190<br />191<br />192<br />193<br />194<br />195<br />196<br />197<br />198<br />199<br />200<br />201<br />202<br />203<br />204<br />205<br />206<br />207<br />208<br />209<br />210<br />211<br />212<br />213<br />214<br />215<br />216<br />217<br />218<br />219<br />220<br />221<br />222<br />223<br />224<br />225<br />226<br />227<br />228<br />229<br />230<br />231<br />232<br />233<br />234<br />235<br />236<br />237<br />238<br />239<br />240<br />241<br />242<br />243<br />244<br />245<br />246<br />247<br />248<br />249<br />250<br />251<br />252<br />253<br />254<br />255<br />256<br />257<br />258<br />259<br />260<br />261<br />262<br />263<br />264<br />265<br />266<br />267<br />268<br />269<br />270<br />271<br />272<br />273<br />274<br />275<br />276<br />277<br />278<br />279<br />280<br />281<br />282<br />283<br />284<br />285<br />286<br />287<br />288<br />289RcParams({u'agg.path.chunksize': 0,<br />          u'animation.avconv_args': [],<br />          u'animation.avconv_path': u'avconv',<br />          u'animation.bitrate': -1,<br />          u'animation.codec': u'mpeg4',<br />          u'animation.convert_args': [],<br />          u'animation.convert_path': u'convert',<br />          u'animation.ffmpeg_args': [],<br />          u'animation.ffmpeg_path': u'ffmpeg',<br />          u'animation.frame_format': u'png',<br />          u'animation.html': u'none',<br />          u'animation.mencoder_args': [],<br />          u'animation.mencoder_path': u'mencoder',<br />          u'animation.writer': u'ffmpeg',<br />          u'axes.axisbelow': False,<br />          u'axes.edgecolor': u'k',<br />          u'axes.facecolor': u'w',<br />          u'axes.formatter.limits': [-7, 7],<br />          u'axes.formatter.use_locale': False,<br />          u'axes.formatter.use_mathtext': False,<br />          u'axes.formatter.useoffset': True,<br />          u'axes.grid': False,<br />          u'axes.grid.axis': u'both',<br />          u'axes.grid.which': u'major',<br />          u'axes.hold': True,<br />          u'axes.labelcolor': u'k',<br />          u'axes.labelpad': 5.0,<br />          u'axes.labelsize': u'medium',<br />          u'axes.labelweight': u'normal',<br />          u'axes.linewidth': 1.0,<br />          u'axes.prop_cycle': cycler(u'color', [u'b', u'g', u'r', u'c', u'm', u'y', u'k']),<br />          u'axes.spines.bottom': True,<br />          u'axes.spines.left': True,<br />          u'axes.spines.right': True,<br />          u'axes.spines.top': True,<br />          u'axes.titlesize': u'large',<br />          u'axes.titleweight': u'normal',<br />          u'axes.unicode_minus': True,<br />          u'axes.xmargin': 0.0,<br />          u'axes.ymargin': 0.0,<br />          u'axes3d.grid': True,<br />          u'backend': u'TkAgg',<br />          u'backend.qt4': u'PyQt4',<br />          u'backend.qt5': u'PyQt5',<br />          u'backend_fallback': True,<br />          u'boxplot.bootstrap': None,<br />          u'boxplot.boxprops.color': u'b',<br />          u'boxplot.boxprops.linestyle': u'-',<br />          u'boxplot.boxprops.linewidth': 1.0,<br />          u'boxplot.capprops.color': u'k',<br />          u'boxplot.capprops.linestyle': u'-',<br />          u'boxplot.capprops.linewidth': 1.0,<br />          u'boxplot.flierprops.color': u'b',<br />          u'boxplot.flierprops.linestyle': u'none',<br />          u'boxplot.flierprops.linewidth': 1.0,<br />          u'boxplot.flierprops.marker': u'+',<br />          u'boxplot.flierprops.markeredgecolor': u'k',<br />          u'boxplot.flierprops.markerfacecolor': u'b',<br />          u'boxplot.flierprops.markersize': 6.0,<br />          u'boxplot.meanline': False,<br />          u'boxplot.meanprops.color': u'r',<br />          u'boxplot.meanprops.linestyle': u'-',<br />          u'boxplot.meanprops.linewidth': 1.0,<br />          u'boxplot.medianprops.color': u'r',<br />          u'boxplot.medianprops.linestyle': u'-',<br />          u'boxplot.medianprops.linewidth': 1.0,<br />          u'boxplot.notch': False,<br />          u'boxplot.patchartist': False,<br />          u'boxplot.showbox': True,<br />          u'boxplot.showcaps': True,<br />          u'boxplot.showfliers': True,<br />          u'boxplot.showmeans': False,<br />          u'boxplot.vertical': True,<br />          u'boxplot.whiskerprops.color': u'b',<br />          u'boxplot.whiskerprops.linestyle': u'--',<br />          u'boxplot.whiskerprops.linewidth': 1.0,<br />          u'boxplot.whiskers': 1.5,<br />          u'contour.corner_mask': True,<br />          u'contour.negative_linestyle': u'dashed',<br />          u'datapath': u'c:\\\\python27\\\\lib\\\\site-packages\\\\matplotlib\\\\mpl-data',<br />          u'docstring.hardcopy': False,<br />          u'errorbar.capsize': 3.0,<br />          u'examples.directory': u'',<br />          u'figure.autolayout': False,<br />          u'figure.dpi': 80.0,<br />          u'figure.edgecolor': u'w',<br />          u'figure.facecolor': u'0.75',<br />          u'figure.figsize': [8.0, 6.0],<br />          u'figure.frameon': True,<br />          u'figure.max_open_warning': 20,<br />          u'figure.subplot.bottom': 0.1,<br />          u'figure.subplot.hspace': 0.2,<br />          u'figure.subplot.left': 0.125,<br />          u'figure.subplot.right': 0.9,<br />          u'figure.subplot.top': 0.9,<br />          u'figure.subplot.wspace': 0.2,<br />          u'figure.titlesize': u'medium',<br />          u'figure.titleweight': u'normal',<br />          u'font.cursive': [u'Apple Chancery',<br />                            u'Textile',<br />                            u'Zapf Chancery',<br />                            u'Sand',<br />                            u'Script MT',<br />                            u'Felipa',<br />                            u'cursive'],<br />          u'font.family': [u'sans-serif'],<br />          u'font.fantasy': [u'Comic Sans MS',<br />                            u'Chicago',<br />                            u'Charcoal',<br />                            u'ImpactWestern',<br />                            u'Humor Sans',<br />                            u'fantasy'],<br />          u'font.monospace': [u'Bitstream Vera Sans Mono',<br />                              u'DejaVu Sans Mono',<br />                              u'Andale Mono',<br />                              u'Nimbus Mono L',<br />                              u'Courier New',<br />                              u'Courier',<br />                              u'Fixed',<br />                              u'Terminal',<br />                              u'monospace'],<br />          u'font.sans-serif': [u'Bitstream Vera Sans',<br />                               u'DejaVu Sans',<br />                               u'Lucida Grande',<br />                               u'Verdana',<br />                               u'Geneva',<br />                               u'Lucid',<br />                               u'Arial',<br />                               u'Helvetica',<br />                               u'Avant Garde',<br />                               u'sans-serif'],<br />          u'font.serif': [u'Bitstream Vera Serif',<br />                          u'DejaVu Serif',<br />                          u'New Century Schoolbook',<br />                          u'Century Schoolbook L',<br />                          u'Utopia',<br />                          u'ITC Bookman',<br />                          u'Bookman',<br />                          u'Nimbus Roman No9 L',<br />                          u'Times New Roman',<br />                          u'Times',<br />                          u'Palatino',<br />                          u'Charter',<br />                          u'serif'],<br />          u'font.size': 12.0,<br />          u'font.stretch': u'normal',<br />          u'font.style': u'normal',<br />          u'font.variant': u'normal',<br />          u'font.weight': u'normal',<br />          u'grid.alpha': 1.0,<br />          u'grid.color': u'k',<br />          u'grid.linestyle': u':',<br />          u'grid.linewidth': 0.5,<br />          u'image.aspect': u'equal',<br />          u'image.cmap': u'jet',<br />          u'image.composite_image': True,<br />          u'image.interpolation': u'bilinear',<br />          u'image.lut': 256,<br />          u'image.origin': u'upper',<br />          u'image.resample': False,<br />          u'interactive': False,<br />          u'keymap.all_axes': [u'a'],<br />          u'keymap.back': [u'left', u'c', u'backspace'],<br />          u'keymap.forward': [u'right', u'v'],<br />          u'keymap.fullscreen': [u'f', u'ctrl+f'],<br />          u'keymap.grid': [u'g'],<br />          u'keymap.home': [u'h', u'r', u'home'],<br />          u'keymap.pan': [u'p'],<br />          u'keymap.quit': [u'ctrl+w', u'cmd+w'],<br />          u'keymap.save': [u's', u'ctrl+s'],<br />          u'keymap.xscale': [u'k', u'L'],<br />          u'keymap.yscale': [u'l'],<br />          u'keymap.zoom': [u'o'],<br />          u'legend.borderaxespad': 0.5,<br />          u'legend.borderpad': 0.4,<br />          u'legend.columnspacing': 2.0,<br />          u'legend.edgecolor': u'inherit',<br />          u'legend.facecolor': u'inherit',<br />          u'legend.fancybox': False,<br />          u'legend.fontsize': u'large',<br />          u'legend.framealpha': None,<br />          u'legend.frameon': True,<br />          u'legend.handleheight': 0.7,<br />          u'legend.handlelength': 2.0,<br />          u'legend.handletextpad': 0.8,<br />          u'legend.isaxes': True,<br />          u'legend.labelspacing': 0.5,<br />          u'legend.loc': u'upper right',<br />          u'legend.markerscale': 1.0,<br />          u'legend.numpoints': 2,<br />          u'legend.scatterpoints': 3,<br />          u'legend.shadow': False,<br />          u'lines.antialiased': True,<br />          u'lines.color': u'b',<br />          u'lines.dash_capstyle': u'butt',<br />          u'lines.dash_joinstyle': u'round',<br />          u'lines.linestyle': u'-',<br />          u'lines.linewidth': 1.0,<br />          u'lines.marker': u'None',<br />          u'lines.markeredgewidth': 0.5,<br />          u'lines.markersize': 6.0,<br />          u'lines.solid_capstyle': u'projecting',<br />          u'lines.solid_joinstyle': u'round',<br />          u'markers.fillstyle': u'full',<br />          u'mathtext.bf': u'serif:bold',<br />          u'mathtext.cal': u'cursive',<br />          u'mathtext.default': u'it',<br />          u'mathtext.fallback_to_cm': True,<br />          u'mathtext.fontset': u'cm',<br />          u'mathtext.it': u'serif:italic',<br />          u'mathtext.rm': u'serif',<br />          u'mathtext.sf': u'sans\\\\-serif',<br />          u'mathtext.tt': u'monospace',<br />          u'nbagg.transparent': True,<br />          u'patch.antialiased': True,<br />          u'patch.edgecolor': u'k',<br />          u'patch.facecolor': u'b',<br />          u'patch.linewidth': 1.0,<br />          u'path.effects': [],<br />          u'path.simplify': True,<br />          u'path.simplify_threshold': 0.1111111111111111,<br />          u'path.sketch': None,<br />          u'path.snap': True,<br />          u'pdf.compression': 6,<br />          u'pdf.fonttype': 3,<br />          u'pdf.inheritcolor': False,<br />          u'pdf.use14corefonts': False,<br />          u'pgf.debug': False,<br />          u'pgf.preamble': [],<br />          u'pgf.rcfonts': True,<br />          u'pgf.texsystem': u'xelatex',<br />          u'plugins.directory': u'.matplotlib_plugins',<br />          u'polaraxes.grid': True,<br />          u'ps.distiller.res': 6000,<br />          u'ps.fonttype': 3,<br />          u'ps.papersize': u'letter',<br />          u'ps.useafm': False,<br />          u'ps.usedistiller': False,<br />          u'savefig.bbox': None,<br />          u'savefig.directory': u'~',<br />          u'savefig.dpi': 100.0,<br />          u'savefig.edgecolor': u'w',<br />          u'savefig.facecolor': u'w',<br />          u'savefig.format': u'png',<br />          u'savefig.frameon': True,<br />          u'savefig.jpeg_quality': 95,<br />          u'savefig.orientation': u'portrait',<br />          u'savefig.pad_inches': 0.1,<br />          u'savefig.transparent': False,<br />          u'svg.fonttype': u'path',<br />          u'svg.image_inline': True,<br />          u'svg.image_noscale': False,<br />          u'text.antialiased': True,<br />          u'text.color': u'k',<br />          u'text.dvipnghack': None,<br />          u'text.hinting': u'auto',<br />          u'text.hinting_factor': 8,<br />          u'text.latex.preamble': [],<br />          u'text.latex.preview': False,<br />          u'text.latex.unicode': False,<br />          u'text.usetex': False,<br />          u'timezone': u'UTC',<br />          u'tk.window_focus': False,<br />          u'toolbar': u'toolbar2',<br />          u'verbose.fileo': u'sys.stdout',<br />          u'verbose.level': u'silent',<br />          u'webagg.open_in_browser': True,<br />          u'webagg.port': 8988,<br />          u'webagg.port_retries': 50,<br />          u'xtick.color': u'k',<br />          u'xtick.direction': u'in',<br />          u'xtick.labelsize': u'medium',<br />          u'xtick.major.pad': 4.0,<br />          u'xtick.major.size': 4.0,<br />          u'xtick.major.width': 0.5,<br />          u'xtick.minor.pad': 4.0,<br />          u'xtick.minor.size': 2.0,<br />          u'xtick.minor.visible': False,<br />          u'xtick.minor.width': 0.5,<br />          u'ytick.color': u'k',<br />          u'ytick.direction': u'in',<br />          u'ytick.labelsize': u'medium',<br />          u'ytick.major.pad': 4.0,<br />          u'ytick.major.size': 4.0,<br />          u'ytick.major.width': 0.5,<br />          u'ytick.minor.pad': 4.0,<br />          u'ytick.minor.size': 2.0,<br />          u'ytick.minor.visible': False,<br />          u'ytick.minor.width': 0.5})<br /><br /><br />在matplotlib模块载入的时候会调用rc_params函数，并把得到的配置字典保存到rcParams变量中。 <br />matplotlib将使用rcParams变量中的配置进行绘图。用户可以直接修改此字典中的配置，所做的改变会反映到此后所绘制的图中。例如下面的脚本所绘制的线将带有圆形的点标识符：<br />1<br />2<br />3<br />4matplotlib.rcParams[\"lines.marker\"] = \"o\"<br />import pylab<br />pylab.plot([1,2,3],[1,2,3])<br />pylab.show()<br /><br /><br /><br />4 绘制多轴图<br />一个绘图对象(Figure)可以包含多个轴(axis)，在matplotlib中用轴表示一个绘图区域，可以将其理解为子图。上面的第一个例子中，绘图对象只包括一个轴，因此只显示了一个轴(子图)。我们可以使用subplot函数快速绘制有多个轴的图表。subplot函数的调用形式如下：  <br />subplot(numRows, numCols, plotNum)    <br />subplot将整个绘图区域等分为numRows行 * numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum这三个数都小于10的话，可以把它们缩写为一个整数，例如subplot(323)和subplot(3,2,3)是相同的。subplot在plotNum指定的区域中创建一个轴对象。如果新创建的轴和之前创建的轴重叠的话，之前的轴将被删除。<br />下面的程序创建3行2列共6个轴，通过axisbg参数给每个轴设置不同的背景颜色。<br />1<br />2<br />3for idx, color in enumerate(\"rgbyck\"):<br />    plt.subplot(320+idx+1, axisbg=color)<br />plt.show()<br /><br /><br /><br />如果希望某个轴占据整个行或者列的话，可以如下调用subplot：<br />1<br />2<br />3<br />4plt.subplot(221) # 第一行的左图<br />plt.subplot(222) # 第一行的右图<br />plt.subplot(212) # 第二整行<br />plt.show()<br /><br /><br /><br />5 Artist对象<br />matplotlib API包含有三层：<br />backend_bases.FigureCanvas : 图表的绘制领域  <br />backend_bases.Renderer : 知道如何在FigureCanvas上如何绘图  <br />artist.Artist : 知道如何使用Renderer在FigureCanvas上绘图  <br />FigureCanvas和Renderer需要处理底层的绘图操作。Artist则处理所有的高层结构，例如处理图表、文字和曲线等的绘制和布局。通常我们只和Artist打交道，而不需要关心底层的绘制细节。     <br />Artists分为简单类型和容器类型两种。简单类型的Artists为标准的绘图元件，例如Line2D、 Rectangle、 Text、AxesImage 等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、 Axes、Figure等。<br />直接使用Artists创建图表的标准流程如下：<br />+ 创建Figure对象<br />+ 用Figure对象创建一个或者多个Axes或者Subplot对象<br />+ 调用Axies等对象的方法创建各种简单类型的Artists    <br />下面首先调用pyplot.figure函数创建Figure对象，然后调用Figure对象的add_axes方法在其中创建一个Axes对象，add_axes的参数是一个形如[left, bottom, width, height]的列表，这些数值分别指定所创建的Axes对象相对于fig的位置和大小，取值范围都在0到1之间：<br />1<br />2fig = plt.figure()<br />ax = fig.add_axes([0.15, 0.1, 0.7, 0.3])<br /><br /><br /><br />然后我们调用ax的plot方法绘图，创建一条曲线，并且返回此曲线对象(Line2D)。<br />1<br />2line, = ax.plot([1,2,3],[1,2,1])<br />ax.lines<br /><br /><br />1[<matplotlib.lines.Line2D at 0x15d0f940>]<br /><br /><br />ax.lines是一个包含ax所有曲线的列表，后续的ax.plot调用会往此列表中添加新的曲线。如果想删除某条曲线的话，直接从此列表中删除即可。<br />Axes对象还包括许多其它的Artists对象，例如我们可以通过调用set_xlabel设置其X轴上的标题：<br />1 ax.set_xlabel(\"time\")<br /><br /><br />1<matplotlib.text.Text at 0x15e6e9e8><br /><br /><br />Axes的xaxis属性是一个XAxis对象：<br />1ax.xaxis<br /><br /><br />1<matplotlib.axis.XAxis at 0x15e6eef0><br /><br /><br />XAxis的label属性是一个Text对象：<br />1ax.xaxis.label<br /><br /><br />1<matplotlib.text.Text at 0x15e6e9e8><br /><br /><br />1ax.xaxis.label.get_text()<br /><br /><br />1u'time'<br /><br /><br />5.1 Artist的属性<br />图表中的每个元素都用一个matplotlib的Artist对象表示，而每个Artist对象都有一大堆属性控制其显示效果。例如Figure对象和Axes对象都有patch属性作为其背景，它的值是一个Rectangle对象。通过设置它的一些属性可以修改Figrue图表的背景颜色或者透明度等属性，下面的例子将图表的背景颜色设置为绿色：<br />1<br />2<br />3<br />4fig = plt.figure()<br />fig.show()<br />fig.patch.set_color(\"g\")<br />fig.canvas.draw()<br /><br /><br />1<matplotlib.figure.Figure at 0x437cc50><br /><br /><br />patch的color属性通过set_color函数进行设置，属性修改之后并不会立即反映到图表的显示上，还需要调用fig.canvas.draw()函数才能够更新显示。  <br />Artist对象的所有属性都通过相应的 get_* 和 set_* 函数进行读写，如果你想用一条语句设置多个属性的话，可以使用set函数：<br />1<br />2fig.set(alpha=0.5, zorder=2)<br />fig.set_alpha(0.5*fig.get_alpha())<br /><br /><br />5.2 Figure容器<br />现在我们知道如何观察和修改已知的某个Artist对象的属性，接下来要解决如何找到指定的Artist对象。前面我们介绍过Artist对象有容器类型和简单类型两种，这一节让我们来详细看看容器类型的内容。<br />最大的Artist容器是matplotlib.figure.Figure，它包括组成图表的所有元素。图表的背景是一个Rectangle对象，用Figure.patch属性表示。当你通过调用add_subplot或者add_axes方法往图表中添加轴(子图时)，这些子图都将添加到Figure.axes属性中，同时这两个方法也返回添加进axes属性的对象，注意返回值的类型有所不同，实际上AxesSubplot是Axes的子类。<br />1<br />2<br />3fig = plt.figure()<br />ax1 = fig.add_subplot(211)<br />ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.3])<br /><br /><br /><br />1fig.axes<br /><br /><br />1<br />2[<matplotlib.axes._subplots.AxesSubplot at 0x1603bc18>,<br /> <matplotlib.axes._axes.Axes at 0x16705320>]<br /><br /><br />1ax1<br /><br /><br />1<matplotlib.axes._subplots.AxesSubplot at 0x1603bc18><br /><br /><br />1ax2<br /><br /><br />1<matplotlib.axes._axes.Axes at 0x16705320><br /><br /><br />不建议直接对Figure.axes属性进行列表操作，而应该使用add_subplot, add_axes, delaxes等方法进行添加和删除操作。<br />5.3 Axes容器<br />Axes容器是整个matplotlib库的核心，它包含了组成图表的众多Artist对象，并且有许多方法函数帮助我们创建、修改这些对象。和Figure一样，它有一个patch属性作为背景，当它是笛卡尔坐标时，patch属性是一个Rectangle对象，而当它是极坐标时，patch属性则是Circle对象。例如下面的语句设置Axes对象的背景颜色为绿色：<br />1<br />2<br />3fig = plt.figure()<br />ax = fig.add_subplot(111)<br />ax.patch.set_facecolor(\"green\")<br /><br /><br /><br />当你调用Axes的绘图方法（例如plot），它将创建一组Line2D对象，并将所有的关键字参数传递给这些Line2D对象，并将它们添加进Axes.lines属性中，最后返回所创建的Line2D对象列表：<br />1<br />2<br />3x, y = np.random.rand(2, 100)<br />line, = ax.plot(x, y, \"-\", color=\"blue\", linewidth=2)<br />line<br /><br /><br />1<matplotlib.lines.Line2D at 0x160f7dd8><br /><br /><br />1ax.lines<br /><br /><br />1[<matplotlib.lines.Line2D at 0x160f7dd8>]<br /><br /><br />与plot方法类似，绘制直方图的方法bar和绘制柱状统计图的方法hist将创建一个Patch对象的列表，每个元素实际上都是Patch的子类Rectangle，并且将所创建的Patch对象都添加进Axes.patches属性中：<br />1<br />2ax = fig.add_subplot(111)<br />n, bins, rects = ax.hist(np.random.randn(1000), 50, facecolor=\"blue\")<br /><br /><br />1rects<br /><br /><br />1<a list of 50 Patch objects><br /><br /><br />1rects[0]<br /><br /><br />1<matplotlib.patches.Rectangle at 0x12cefbe0><br /><br /><br />1ax.patches[0]<br /><br /><br />1<matplotlib.patches.Rectangle at 0x12cefbe0><br /><br /><br />一般我们不会直接对Axes.lines或者Axes.patches属性进行操作，而是调用add_line或者add_patch等方法，这些方法帮助我们完成许多属性设置工作：<br />1<br />2<br />3fig = plt.figure()<br />ax = fig.add_subplot(111)<br />rect = matplotlib.patches.Rectangle((1,1), width=5, height=12)<br /><br /><br /><br />1 print rect.get_axes() # rect的axes属性为空<br /><br /><br />1None<br /><br /><br />1ax.add_patch(rect) # 将rect添加进ax<br /><br /><br />1<matplotlib.patches.Rectangle at 0x160df940><br /><br /><br />1rect.get_axes() # 于是rect的axes属性就是ax<br /><br /><br />1<matplotlib.axes._subplots.AxesSubplot at 0x13377668><br /><br /><br />1ax.get_xlim() # ax的X轴范围为0到1，无法显示完整的rect<br /><br /><br />1(0.0, 1.0)<br /><br /><br />1ax.dataLim._get_bounds() # 数据的范围和rect的大小一致<br /><br /><br />1(1.0, 1.0, 5.0, 12.0)<br /><br /><br />1ax.autoscale_view() # 自动调整坐标轴范围<br /><br /><br />1ax.get_xlim() # 于是X轴可以完整显示rect<br /><br /><br />1(1.0, 6.0)<br /><br /><br />1 plt.show()<br /><br /><br />1<br /><br /><br />1(0.0, 14.0)<br /><br /><br />下面列出Axes的创建Artist对象的方法：   <br /><br /><br /><br />Axes的方法<br />所创建的对象<br />添加进的列表<br /><br /><br /><br /><br />annotate<br />Annotate<br />texts<br /><br /><br />bars<br />Rectangle<br />patches<br /><br /><br />errorbar<br />Line2D, Rectangle<br />lines,patches<br /><br /><br />fill<br />Polygon<br />patches<br /><br /><br />hist<br />Rectangle<br />patches<br /><br /><br />imshow<br />AxesImage<br />images<br /><br /><br />legend<br />Legend<br />legends<br /><br /><br />plot<br />Line2D<br />lines<br /><br /><br />scatter<br />PathCollection<br />Collections<br /><br /><br />text<br />Text<br />texts<br /><br /><br /><br />下面以绘制散列图(scatter)为例，验证一下：<br />1<br />2<br />3<br />4fig = plt.figure()<br />ax = fig.add_subplot(111)<br />t = ax.scatter([1,2,3], [4,5,6])<br />t # 返回值为PathCollection对象<br /><br /><br />1<matplotlib.collections.PathCollection at 0x16ec5160><br /><br /><br /><br />1ax.collections # 返回的对象已经添加进了collections列表中<br /><br /><br />1[<matplotlib.collections.PathCollection at 0x12dc3400>]<br /><br /><br />1t.get_sizes() # 获得Collection的点数<br /><br /><br />1array([20])<br /><br /><br />5.4 Axis容器<br />Axis容器包括坐标轴上的刻度线、刻度文本、坐标网格以及坐标轴标题等内容。刻度包括主刻度和副刻度，分别通过Axis.get_major_ticks和Axis.get_minor_ticks方法获得。每个刻度线都是一个XTick或者YTick对象，它包括实际的刻度线和刻度文本。为了方便访问刻度线和文本，Axis对象提供了get_ticklabels和get_ticklines方法分别直接获得刻度线和刻度文本：<br />1<br />2<br />3plt.plot([1,2,3],[4,5,6])<br />axis = plt.gca().xaxis<br />axis.get_ticklocs() # 获得刻度的位置列表<br /><br /><br />1array([ 1. ,  1.5,  2. ,  2.5,  3. ])<br /><br /><br /><br />1axis.get_ticklabels() # 获得刻度标签列表<br /><br /><br />1<a list of 5 Text major ticklabel objects><br /><br /><br />1[x.get_text() for x in axis.get_ticklabels()] # 获得刻度的文本字符串<br /><br /><br />1[u'1.0', u'1.5', u'2.0', u'2.5', u'3.0']<br /><br /><br />1axis.get_ticklines() # 获得主刻度线列表，图的上下刻度线共10条<br /><br /><br />1<a list of 10 Line2D ticklines objects><br /><br /><br />1axis.get_ticklines(minor=True) # 获得副刻度线列表<br /><br /><br />1<a list of 0 Line2D ticklines objects><br /><br /><br />获得刻度线或者刻度标签之后，可以设置其各种属性，下面设置刻度线为绿色粗线，文本为红色并且旋转45度：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11lines=plt.plot([1,2,3],[4,5,6])<br />axis = plt.gca().xaxis<br />for label in axis.get_ticklabels():<br />    label.set_color(\"red\")<br />    label.set_rotation(45)<br />    label.set_fontsize(16)<br />for line in axis.get_ticklines():<br />    line.set_color(\"green\")<br />    line.set_markersize(25)<br />    line.set_markeredgewidth(3)<br />plt.show()<br /><br /><br /><br />上面的例子中，获得的副刻度线列表为空，这是因为用于计算副刻度的对象缺省为NullLocator，它不产生任何刻度线；而计算主刻度的对象为AutoLocator，它会根据当前的缩放等配置自动计算刻度的位置：<br />1axis.get_minor_locator() # 计算副刻度的对象<br /><br /><br />1<matplotlib.ticker.NullLocator at 0xeb17358><br /><br /><br />1axis.get_major_locator() # 计算主刻度的对象<br /><br /><br />1<matplotlib.ticker.AutoLocator at 0x12d834a8><br /><br /><br />我们可以使用程序为Axis对象设置不同的Locator对象，用来手工设置刻度的位置；设置Formatter对象用来控制刻度文本的显示。下面的程序设置X轴的主刻度为pi/4，副刻度为pi/20，并且主刻度上的文本以pi为单位：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48# -*- coding: utf-8 -*-<br />from matplotlib.ticker import MultipleLocator, FuncFormatter<br />x = np.arange(0, 4*np.pi, 0.01)<br />y = np.sin(x)<br />plt.figure(figsize=(8,4))<br />plt.plot(x, y)<br />ax = plt.gca()<br /><br />def pi_formatter(x, pos):<br />    \"\"\"<br />    比较罗嗦地将数值转换为以pi/4为单位的刻度文本<br />    \"\"\"<br />    m = np.round(x / (np.pi/4))<br />    n = 4<br />    if m% 2==0: m, n = m/2, n/2<br />    if m% 2==0: m, n = m/2, n/2<br />    if m == 0:<br />        return \"0\"<br />    if m == 1 and n == 1:<br />        return \"$\\pi$\"<br />    if n == 1:<br />        return r\"$% d \\pi$\" %  m<br />    if m == 1:<br />        return r\"$\\frac{\\pi}{% d}$\" %  n<br />    return r\"$\\frac{% d \\pi}{% d}$\" %  (m,n)<br /><br /># 设置两个坐标轴的范围<br />plt.ylim(-1.5,1.5)<br />plt.xlim(0, np.max(x))<br /><br /># 设置图的底边距<br />plt.subplots_adjust(bottom = 0.15)<br /><br />plt.grid() #开启网格<br /><br /># 主刻度为pi/4<br />ax.xaxis.set_major_locator( MultipleLocator(np.pi/4) )<br /><br /># 主刻度文本用pi_formatter函数计算<br />ax.xaxis.set_major_formatter( FuncFormatter( pi_formatter ) )<br /><br /># 副刻度为pi/20<br />ax.xaxis.set_minor_locator( MultipleLocator(np.pi/20) )<br /><br /># 设置刻度文本的大小<br />for tick in ax.xaxis.get_major_ticks():<br />    tick.label1.set_fontsize(10)<br />plt.show()<br /><br /><br /><br />关于刻度的定位和文本格式的东西都在matplotlib.ticker中定义，程序中使用到如下两个类：<br /> MultipleLocator :  以指定值的整数倍为刻度放置刻度线   <br /> FuncFormatter :  使用指定的函数计算刻度文本，他会传递给所指定的函数两个参数：刻度值和刻度序号，程序中通过比较笨的办法计算出刻度值所对应的刻度文本  <br />此外还有很多预定义的Locator和Formatter类，详细内容请参考相应的API文档。<br />Markdown中插入数学公式的方法<br />1. 使用MathJax引擎  <br />首先在Markdown中添加MathJax引擎很简单，   <br />然后，再使用Tex写公式。\\$\\$公式\\$\\$表示行间公式，本来Tex中使用(公式)表示行内公式，但因为Markdown中\\是转义字符，所以在Markdown中输入行内公式使用\\\\(公式\\\\)，如下代码：<br />行间公式： <br /><br />$$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$<br />行内公式： \\(x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\)<br /><br />1<br /><br />","tags": "python pylab模块 plot 9","url": "blog/python_beginning/9matplotlib.html"},
{"title": "函数","text": "<br />接下来会介绍如果将语句组织成函数。还会详细介绍参数（parameter）和作用域（scope），以及递归的概念。<br />1 创建函数<br />内建的callable函数可以用来判断函数是否可调用：<br />1<br />2<br />3<br />4import math<br />x=1<br />y=math.sqrt<br />callable(x)<br /><br /><br />1False<br /><br /><br />1callable(y)<br /><br /><br />1True<br /><br /><br />怎么定义函数呢？使用def语句即可：<br />1<br />2def hello(name):<br />    return 'Hello, '+name+'!'<br /><br /><br />1print hello('world')<br /><br /><br />1Hello, world!<br /><br /><br />本例中return语句是用来从函数中返回值的。<br />1.1 记录函数<br />如果想给函数写文档，让后面使用该函数人能理解的话，可以加入注释（例如，#hello、”“”hello”“”“、’‘’hello’‘’）。下面代码演示了如何给函数添加文档字符串：<br />1<br />2<br />3def square(x):<br />    '''Calculates the square of the number x.'''<br />    return x*x<br /><br /><br />文档字符串可以按如下方式访问：<br />1square.__doc__              #__doc__是函数属性。属性名中的双下划线表示它是个特殊属性。<br /><br /><br />1'Calculates the square of the number x.'<br /><br /><br />内建的help函数是非常有用的，可以得到关于函数，包括它的文档字符串信息。<br />1help(square)<br /><br /><br />1<br />2<br />3<br />4Help on function square in module __main__:<br /><br />square(x)<br />    Calculates the square of the number x.<br /><br /><br />2 参数<br />写在def语句中函数名后面的变量通常叫做函数的形式参数，而调用函数时提供的值是实际参数，或者称为参数。<br />2.1 我能改变参数吗<br />1<br />2<br />3<br />4<br />5def try_to_change(n):<br />    n='Gumby'<br />name='Entity'<br />try_to_change(name)<br />name<br /><br /><br />1'Entity'<br /><br /><br />在try_to_change内，参数n获得了新值，但是它没有影响到name变量。   <br />字符串（以及数字和元组）是不可改变的，即无法被修改（只能用新值覆盖）。所以它们做参数的时候也就无需多做介绍。但是如果将可变的数据结构如列表用作参数的时候会发生什么：<br />1<br />2<br />3<br />4<br />5def change(n):<br />    n[0]='Humby'<br />names=['Entity','Thing']<br />change(names)<br />names<br /><br /><br />1['Humby', 'Thing']<br /><br /><br />本例中，参数被改变了。有些奇怪吧？下面不用函数调用再做一次：<br />1<br />2<br />3<br />4names=['Entity','Thing']<br />n=names    #当两个变量同时引用一个列表的时候，它们是同一个对象。<br />n[0]='Gumby'<br />names<br /><br /><br />1['Gumby', 'Thing']<br /><br /><br />1n is names<br /><br /><br />1True<br /><br /><br />如果想避免上述情况，可以复制一个列表的副本。当在序列中做切片的时候，返回的切片就是一个副本。<br />1<br />2<br />3names=['Entity','Thing']<br />n=names[:]<br />n is names<br /><br /><br />1False<br /><br /><br />1n==names<br /><br /><br />1True<br /><br /><br />1<br />2n[0]='Gumby'<br />names<br /><br /><br />1['Entity', 'Thing']<br /><br /><br />1n<br /><br /><br />1['Gumby', 'Thing']<br /><br /><br />使用函数改变数据结构（比如列表或字典）是将程序抽象化的好方法，这时就需要改变参数。假设需要编写一个存储名字并且能用名字、中间名或姓查找联系人的程序，可以使用下面的数据结构：<br />1<br />2<br />3<br />4<br />5<br />6<br />7def init(data):<br />    data['first']={}<br />    data['middle']={}<br />    data['last']={}<br />storage={}   #storage就是参数，需要改变<br />init(storage)<br />storage<br /><br /><br />1{'first': {}, 'last': {}, 'middle': {}}<br /><br /><br />可以看到，函数init包办了初始化的工作，让代码更易读。<br />把自己的名字加入这个数据结构：<br />1<br />2<br />3<br />4me='Magnus Lie Hetland'<br />storage['first']['Magnus']=[me]<br />storage['middle']['Lie']=[me]<br />storage['last']['Hetland']=[me]<br /><br /><br />每个键下面都存储了一个以人名组成的列表。本例中，列表中只有我。   <br />现在如果想得到所有注册中间名为Lie的人，如下：<br />1storage['middle']['Lie']<br /><br /><br />1['Magnus Lie Hetland']<br /><br /><br />将人名加到列表中的步骤有点枯燥乏味，尤其是要加入很多姓名相同的人时，需要扩展已经存储了那些名字的列表，如下：<br />1<br />2<br />3<br />4<br />5my_sister='Anne Lie Hetland'<br />storage['first'].setdefault('Anne',[]).append(my_sister)<br />storage['middle'].setdefault('Lie',[]).append(my_sister)<br />storage['last'].setdefault('Hetland',[]).append(my_sister)<br />storage['first']['Anne']<br /><br /><br />1['Anne Lie Hetland']<br /><br /><br />1storage['middle']['Lie']<br /><br /><br />1['Magnus Lie Hetland', 'Anne Lie Hetland']<br /><br /><br />如果要写个大程序来这样更新列表，那么很显然程序很快就会变得臃肿且笨拙不堪了。   <br />在编写存储名字的函数前，先写个获得名字的函数：<br />1<br />2<br />3def lookup(data, label, name):<br />    return data[label].get(name)<br />lookup(storage,'middle','Lie')<br /><br /><br />1['Magnus Lie Hetland', 'Anne Lie Hetland']<br /><br /><br />标签（比如”middle“）以及名字（比如”Lie“）可以作为参数提供给lookup函数使用，这样会获得包含了全名的列表。    <br />注意，返回的列表和存储在数据结构中的列表是相同的，所以如果列表被修改了，那么也会影响数据结构。    <br />编写存储名字的函数：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11def store(data,full_name):<br />    names=full_name.split()     #拆分full_name，得到一个names列表<br />    if len(names)==2:<br />        names.insert(1,'')     #如果names长度为2（只有首名和末名），则插入一个空字符作为中间名<br />    labels='first','middle','last'    #将'first','middle','last'作为元组存储在labels中，也可以使用列表，只是为了方便而去掉括号<br />    for label, name in zip(labels, names):  #使用zip函数联合标签和名字<br />        people = lookup(data, label, name)<br />        if people:<br />            people.append(full_name)<br />        else:<br />            data[label][name]=[full_name]<br /><br /><br />来试用一下刚刚实现的程序：<br />1<br />2<br />3<br />4Mynames={}<br />init(Mynames)<br />store(Mynames,'Magnus Lie Hetland')<br />lookup(Mynames,'middle','Lie')<br /><br /><br />1['Magnus Lie Hetland']<br /><br /><br />2.2 关键字参数和默认值<br />上述所使用的参数都叫做位置参数，因为它们的位置很重要—事实上比它们的名字更加重要。接下来引入的这个功能可以回避位置问题，当你慢慢习惯使用这个功能以后，就会发现程序规模越大，它们的作用也就越大。   <br />考虑下面两个函数：<br />1<br />2<br />3<br />4def hello_1(greeting,name):<br />    print \"% s,% s\" %  (greeting,name)<br />def hello_2(name,greeting):<br />    print \"% s,% s\" %  (name,greeting)<br /><br /><br />两个代码所实现的是完全一样的功能，只是参数名字反过来了：<br />1<br />2hello_1('Hello','world')<br />hello_2('Hello','world')<br /><br /><br />1<br />2Hello,world<br />Hello,world<br /><br /><br />有些时候（尤其是参数很多的时候），参数的顺序是很难记住的。为了让事情简单些，可以提供参数的名字：<br />1<br />2hello_1(greeting='Hello',name='world')<br />hello_1(name='world',greeting='Hello')<br /><br /><br />1<br />2Hello,world<br />Hello,world<br /><br /><br />这样一来，顺序就完全没影响了。但参数名和值一定要对应。这类使用参数名提供的参数叫做关键字参数。它的作用在于可以明确每个参数的作用。尽管这么做打的字就多了些，但是很显然，每个参数的含义变得更加清晰。而且就算弄乱了参数的顺序，对于程序的功能也没有任何影响。    <br />关键字参数最厉害的地方在于可以在函数中给参数提供默认值：<br />1<br />2def hello_3(greeting='Hello',name='world'):<br />    print \"% s,% s\" %  (greeting,name)<br /><br /><br />当参数具有默认值的时候，调用的时候就不用提供参数了：<br />1hello_3()<br /><br /><br />1Hello,world<br /><br /><br />1hello_3('Greetings')<br /><br /><br />1Greetings,world<br /><br /><br />1hello_3('Greetings','universe')<br /><br /><br />1Greetings,universe<br /><br /><br />但是如果只想提供name参数，而让greeting使用默认值该怎么办呢？<br />1hello_3(name='Gumby')<br /><br /><br />1Hello,Gumby<br /><br /><br />位置和关键字参数是可以联合使用的。把位置参数放置在前面就可以了。<br />2.3 收集参数<br />有些时候让用户提供任意数量的参数是很有用的。比如在名字存储程序中，用户每次只能存一个名字。如果能像下面这样存储多个名字就更好了：   <br />store(data,name1,name2,name3)    <br />用户可以给函数提供任意多的参数。实现起来也不难。试着像下面这样定义函数：     <br />1<br />2def print_params(*params):<br />    print params<br /><br /><br />这里只指定了一个参数，但是前面加上了个星号。这是什么意思？让我们用一个参数调用函数看看会发生什么：<br />1print_params('Testing')<br /><br /><br />1('Testing',)<br /><br /><br />可以看到，结果作为元组打印出来，因为里面有个逗号。那么在params中使用多个参数看看会发生什么：<br />1print_params('Testing',1,2,3)<br /><br /><br />1('Testing', 1, 2, 3)<br /><br /><br />参数前的星号将所有值放置在同一个元组中。可以说是将这些值收集起来，然后使用。不知道能不能联合普通参数？<br />1<br />2<br />3<br />4def print_params_2(title, *params):<br />    print title<br />    print params<br />print_params_2('Params:', 1,2,3)<br /><br /><br />1<br />2Params:<br />(1, 2, 3)<br /><br /><br />所以星号的意思就是“收集其余的位置参数”。如果不提供任何供收集的元素，params就是个空元组：<br />1print_params_2('Nothing:')<br /><br /><br />1<br />2Nothing:<br />()<br /><br /><br />那么能不能处理关键字参数呢？<br />1print_params_2('Hmm...',something=42)<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9---------------------------------------------------------------------------<br /><br />TypeError                                 Traceback (most recent call last)<br /><br /><ipython-input-31-3b2ecc07b82c> in <module>()<br />----> 1 print_params_2('Hmm...',something=42)<br /><br /><br />TypeError: print_params_2() got an unexpected keyword argument 'something'<br /><br /><br />看来不行。所以我们需要另外一个能处理关键字参数的“收集”操作。原来需要在参数前面加上两个星号“**”<br />1<br />2<br />3def print_params_3(**params):<br />    print params<br />print_params_3(x=1,y=2,z=3)<br /><br /><br />1{'y': 2, 'x': 1, 'z': 3}<br /><br /><br />返回的是字典而不是元组。放一起来看看：<br />1<br />2<br />3<br />4<br />5def print_params_4(x,y,z=3,*pospar,**keypar):<br />    print x,y,z<br />    print pospar<br />    print keypar<br />print_params_4(1,2,3,5,6,7,foo=1,bar=2)<br /><br /><br />1<br />2<br />31 2 3<br />(5, 6, 7)<br />{'foo': 1, 'bar': 2}<br /><br /><br />1print_params_4(1,2)<br /><br /><br />1<br />2<br />31 2 3<br />()<br />{}<br /><br /><br />联合使用这些功能，可以做的事就多了。现在回到原来的问题上：怎么实现多个名字同时存储。解决方案如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12def store(data,*full_names):<br />    for full_name in full_names:<br />        names=full_name.split()     <br />        if len(names)==2:<br />            names.insert(1,'')  <br />        labels='first','middle','last'   <br />        for label, name in zip(labels, names): <br />            people = lookup(data, label, name)<br />            if people:<br />                people.append(full_name)<br />            else:<br />                data[label][name]=[full_name]<br /><br /><br />1<br />2<br />3<br />4d={}<br />init(d)<br />store(d,'Magnus Lie Hetland','Luke Skywaller')<br />lookup(d,'last','Skywaller')<br /><br /><br />1['Luke Skywaller']<br /><br /><br />2.4 反转过程<br />如何将参数收集为元组和字典已经讨论过了，但是事实上，如果使用*和**的话，也可以执行相反的操作。那么参数收集的逆过程是什么呢？  <br />1<br />2<br />3def add(x,y):<br />    return x+y<br />add(1,2)<br /><br /><br />13<br /><br /><br />比如说有个包含由两个要相加的数字组成的元组，可以使用*运算符来分配它们到“另一端”：<br />1<br />2params=(1,2)<br />add(*params)<br /><br /><br />13<br /><br /><br />可以使用同样的技术来处理字典—使用双星号运算符。<br />1<br />2<br />3<br />4def hello_3(greeting='Hello',name='world'):<br />    print \"% s,% s\" %  (greeting,name)<br />params={'name':'Sir Robin','greeting':'Well met'}<br />hello_3(**params)<br /><br /><br />1Well met,Sir Robin<br /><br /><br />在定义或调用函数时使用星号（或者双星号）仅传递元组或字典。<br />2.5 练习使用参数<br />下面把上述方法放在一起举个例子： <br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17def story(**kwds):<br />    return 'Once upon a time, there was a ' \\<br />            '% (job)s called % (name)s.' % kwds<br />def power(x,y,*others):<br />    if others:<br />        print 'Received redundant parameters:',others<br />    return pow(x,y)<br />def interval(start,stop=None,step=1):<br />    'Imitates range() for step > 0'<br />    if stop is None:<br />        start,stop=0,start   #指定参数<br />    result=[]<br />    i=start<br />    while i<stop:<br />        result.append(i)<br />        i+=step<br />    return result<br /><br /><br />1print story(job='king',name='Gumby')<br /><br /><br />1Once upon a time, there was a king called Gumby.<br /><br /><br />1print story(name='Sir Robin',job='brave knight')<br /><br /><br />1Once upon a time, there was a brave knight called Sir Robin.<br /><br /><br />1<br />2params={'job':'language','name':'Python'}<br />print story(**params)<br /><br /><br />1Once upon a time, there was a language called Python.<br /><br /><br />1<br />2del params['job']<br />params<br /><br /><br />1{'name': 'Python'}<br /><br /><br />1print story(job='stroke of genius', **params)<br /><br /><br />1Once upon a time, there was a stroke of genius called Python.<br /><br /><br />1power(2,3)<br /><br /><br />18<br /><br /><br />1power(3,2)<br /><br /><br />19<br /><br /><br />1power(y=3,x=2)<br /><br /><br />18<br /><br /><br />1<br />2params=(2,)*2<br />params<br /><br /><br />1(2, 2)<br /><br /><br />1power(*params)<br /><br /><br />14<br /><br /><br />1<br />2params=(2,)*4<br />power(*params)<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6<br />7Received redundant parameters: (2, 2)<br /><br /><br /><br /><br /><br />4<br /><br /><br />1interval(10)<br /><br /><br />1[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br /><br /><br />1interval(1,8,2)<br /><br /><br />1[1, 3, 5, 7]<br /><br /><br />3 作用域<br />到底什么是变量？可以把它们看作是值的名字。在执行x=1赋值语句后，名称x引用到值1。这就像用字典一样，键引用值。变量和所对应的值用的是个“不可见”的字典。内建的vars函数可以返回这个字典：<br />1<br />2<br />3x=1<br />scope=vars()<br />scope['x']<br /><br /><br />11<br /><br /><br />1<br />2scope['x']+=1<br />x<br /><br /><br />12<br /><br /><br />这类“不可见字典”叫做命名空间或者作用域。那么到底有多少个命名空间？除了全局作用域外，每个函数调用都会创建一个新的作用域（局部作用域或局部命名空间）：<br />1<br />2<br />3<br />4<br />5def foo():<br />    x=42<br />x=1<br />foo()<br />x<br /><br /><br />11<br /><br /><br />当调用foo的时候，新的命名空间被创建，它只作用于foo内的代码块。函数内的变量被称为局部变量（local variable）。<br />如果在函数内部将值赋予一个变量，它会自动成为局部变量—除非告知Python将其声明为全局变量：<br />1<br />2<br />3<br />4<br />5<br />6x=1<br />def change_global():<br />    global x<br />    x=x+1<br />change_global()<br />x<br /><br /><br />12<br /><br /><br />4 递归<br />函数可以调用其他函数，也可以调用自身。递归（recursion）简单来说就是引用（或调用）自身的意思。一切用递归实现的功能都可以用循环实现，但有些时候递归函数更易读。<br />首先，计算数n的阶乘。那么怎么计算呢？可以使用循环：<br />1<br />2<br />3<br />4<br />5<br />6def factorial_1(n):<br />    result=n<br />    for i in range(1,n):<br />        result*=i<br />    return result<br />factorial_1(3)<br /><br /><br />16<br /><br /><br />下面来看看使用递归的版本：   <br />1的阶乘是1；   <br />大于1的数n的阶乘是n乘n-1的阶乘。<br />1<br />2<br />3<br />4<br />5<br />6def factorial_2(n):<br />    if n==1:<br />        return 1<br />    else:<br />        return n*factorial_2(n-1)<br />factorial_2(3)<br /><br /><br />16<br /><br /><br />考虑另外一个例子，计算幂（就像内建的pow函数或**运算符一样）。   <br />先看一个简单的例子：power(x,n)是x自乘n-1次的结果。<br />1<br />2<br />3<br />4<br />5<br />6def power_1(x,n):<br />    result=1<br />    for i in range(n):<br />         result*=x<br />    return result<br />power_1(2,3)<br /><br /><br />18<br /><br /><br />接下来把它改为递归版本：<br />对于任意数字x来说，power(x,0)是1；   <br />对于任何大于0的数，power(x,n)是x乘以power(x,n-1)的结果。<br />1<br />2<br />3<br />4<br />5<br />6def power_2(x,n):<br />    if n==0:<br />        return 1<br />    else:<br />        return x*power(x,n-1)<br />power_2(2,3)<br /><br /><br />18<br /><br /><br />5 小结","tags": "python 函数 参数 4","url": "blog/python_beginning/4function.html"},
{"title": "基础知识","text": "<br />大家好！为了能够更系统地了解Python，我开始学习各种教程。为了及时将所学内容和大家分享，同时巩固知识，我决定写这个Python教程。<br />1 安装Python<br />1.1 windows<br />(1) 从 http://www.python.org 下载Python安装包<br />(2) 双击运行Python的Windows Installer，这样会开启Python的安装向导，只需要接受默认设置。<br />1.2 Linux<br />在绝大多数Linux系统中，Python的解释器就已经存在。如果读者需要自己安装Python，可以使用Linux中的包管理器进行安装。如果使用的操作系统为Debian Linux， 那么可以用下面的命令来安装Python: <br />\\$ apt-get install python <br />如果是RedHat Linux，则使用: <br />\\$ yum install python<br />2 Python交互式解释器<br />当启动Python的时候，会出现和下面类似的提示： <br />Python 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32<br />Type “copyright”, “credits” or “license()” for more information. <br />>>>  <br />试着输入下面的命令看看它是否正常工作：    <br />1print 'Hello, world!'<br /><br /><br />1Hello, world!<br /><br /><br />发生了什么？那个>>>符号就是提示符，可以在后面写上Python语句，比如print ‘Hello, world!’。如果按下回车，Python解释器会打印出’Hello, world!’字符串。接下来先从一些简单的Python语句开始，看看能用它们做些什么。<br />3 数据和表达式<br />交互式Python解释器可以当作非常强大的计算器使用，试试以下的例子：<br />11/2<br /><br /><br />10<br /><br /><br />发生了什么？一个整数被另外一个整数除，计算结果的小数部分被截除了，只留下整数部分。这里提供两个有效的解决方案：要用实数（包含小数点的十进制数）进行运算，或让Python改变除法的执行方式。 <br />实数在Python中被称为浮点数（Float，或者Float-point Number），如果参与除法的两个数中有一个数为浮点数，结果亦为浮点数：<br />11.0/2.0<br /><br /><br />10.5<br /><br /><br />11.0/2<br /><br /><br />10.5<br /><br /><br />如果希望Python只执行普通的除法，那么可以在程序前加上以下语句，或者直接在解释器里执行它：<br />1from __future__ import division<br /><br /><br />11/2<br /><br /><br />10.5<br /><br /><br />通过使用上述方法，除法会变得更为合理。上述代码中future前后是两个下划线，以后会对__future__模块进行深入的介绍。Python还提供了另外一种用于实现整除的操作符-双斜线：<br />11//2<br /><br /><br />10<br /><br /><br />就算是浮点数，双斜线也会执行整除：<br />11.0//2.0<br /><br /><br />10.0<br /><br /><br />还有一个非常有用的运算符：<br />11% 2<br /><br /><br />11<br /><br /><br />这是取余运算符—x% y的结果为x除以y的余数。最后一个运算符就是幂（乘方）运算符：<br />12**3<br /><br /><br />18<br /><br /><br />4 变量<br />Python中的变量很好理解，基本上就是代表某值的名字(变量名可以包括字母、数字和下划线，不能以数字开头)。举例来说，如果希望x代表3，只需执行下面的语句即可：<br />1x=3<br /><br /><br />这样的操作称为赋值，值3赋给了变量x。在变量被赋值之后，就可以在表达式中使用变量。<br />1x*2<br /><br /><br />16<br /><br /><br />多个赋值操作可以同时进行：<br />1<br />2x,y,z=1,2,3<br />print x, y, z<br /><br /><br />11 2 3<br /><br /><br />将表达式运算符（+、-、*、/等）放置在赋值运算符（=）的左边，这种写法叫做增量赋值：<br />1<br />2<br />3<br />4x=2<br />x+=1<br />x*=2<br />x<br /><br /><br />16<br /><br /><br />增量赋值可以让代码更加紧凑和简练，很多情况下会更易读。<br />5 语句<br />上面我已经介绍了两类语句：print语句和赋值语句。那么语句和表达式之间有什么区别呢？表达式是某事，而语句是做某事（换句话说就是告诉计算机做什么）。比如2*2是4，而print 2*2打印4。事实上print打印多个表达式也是可行的。<br />1print 'Age', 42  #使用逗号隔开<br /><br /><br />1Age 42<br /><br /><br />6 获取用户输入<br />怎么获取用户提供的值呢？看看非常有用的input函数吧。<br />1x=input(\"x:\")<br /><br /><br />1x:20<br /><br /><br />1y=input(\"y:\")<br /><br /><br />1y:31<br /><br /><br />1print x*y<br /><br /><br />1620<br /><br /><br />输入的值20和31由用户提供，而程序<br />7 函数<br />函数就像可以用来实现特定功能的小程序一样。我们通常把标准函数称为内建函数。比如使用abs函数可以得到数的绝对值，round函数则会把浮点数四舍五入为最接近的整数值：<br />1abs(-10)<br /><br /><br />110<br /><br /><br />1round(0.4)<br /><br /><br />10.0<br /><br /><br />8 模块<br />可以把模块想象成导入到Python中以增强其功能的扩展。需要使用特殊的命令import来导入模块。比如floor函数(向下取整)就在名为math的模块中：<br />1<br />2import math<br />math.floor(2.9)<br /><br /><br />12.0<br /><br /><br />如果想把2.9转化为整数而不是浮点数，可以使用int函数：<br />1int(math.floor(2.9))<br /><br /><br />12<br /><br /><br />在确定自己不会导入多个同名函数（从不同模块导入）的情况下，你可能不希望在每次调用函数的时候，都要写上模块的名字。那么，可以使用import命令的另外一种形式：<br />1<br />2from math import sqrt<br />sqrt(9)<br /><br /><br />13.0<br /><br /><br />事实上，可以使用变量来引用函数。比如，通过foo=math.sqrt进行赋值，然后就可以使用foo来计算平方根了：foo(4)的结果为2.0。也可以为函数提供别名：from math import sqrt as foobar<br />9 保存并执行程序<br />交互式解释器是Python的强项之一，它让实时检验解决方案并且体验这门语言成为了现实。但是，在交互式解释器里面输入的一切都会在它退出的时候丢失。我们真正想做的事情是编写自己和他人都能运行的程序。如何实现呢？  <br />首先，需要一个文本编辑器。然后将程序保存在以.py结尾的文本文件中。如果使用Python解释器可通过Edit->Run或者按下Ctrl+F5键来运行程序。如果使用DOS窗口或者Linux中的Shell提示符可通过运行以下命令执行脚本：python *.py<br />10 注释<br />井号（#）在Python中有特殊作用。在代码中输入它的时候，它右边的一切都会被忽略。比如：<br /># 打印圆的周长：  <br />print 2*pi*radius<br />这里的第一行称为注释。为了让别人能够更容易理解程序，使用注释是非常有效的。<br />11 字符串<br />在程序中可以使用双引号将字符串括起来：<br />1\"Let's go!\"<br /><br /><br />1\"Let's go!\"<br /><br /><br />也可以使用单引号将字符串括起来：<br />1'Hello,world!'<br /><br /><br />1'Hello,world!'<br /><br /><br />1'Let's go!'<br /><br /><br />1<br />2<br />3<br />4  File \"<ipython-input-3-572d1938a729>\", line 1<br />    'Let's go!'<br />         ^<br />SyntaxError: invalid syntax<br /><br /><br />11.1 转义符号-反斜线<br />这时可以使用反斜线(\\)对字符串中的引号进行转义。<br />1'Let\\'s go!'<br /><br /><br />1\"Let's go!\"<br /><br /><br />11.2 拼接字符串<br />Python中该怎么拼接字符串呢？就像进行加法运算一样：<br />1\"Hello, \"+\"world!\"<br /><br /><br />1'Hello, world!'<br /><br /><br />11.3 字符串表示，str和repr<br />通过Python打印的字符串还是被引号括起来的。这是因为Python在打印值时会保持该值在Python代码中的状态。如果使用print语句，结果就不一样了：<br />110000L<br /><br /><br />110000L<br /><br /><br />1print \"Hello, \"+\"world!\"<br /><br /><br />1Hello, world!<br /><br /><br />1print 10000L<br /><br /><br />110000<br /><br /><br />可以看到，长整型数10000L被转换成了数字10000。但是，当你想知道一个变量的值时，可能会对它是整型还是长整型感兴趣。   <br />我们在这里讨论的实际上是值被转换为字符串的两种机制。可以通过以下两个函数来实现这两种机制：一是通过str函数，它会把值转换为合理形式的字符串，以便用户可以理解；而repr会创建一个字符串，它以合法的Python表达式的形式来表达值。比如：<br />1print repr('Hello, world!')<br /><br /><br />1'Hello, world!'<br /><br /><br />1print repr(10000L)<br /><br /><br />110000L<br /><br /><br />1print str('Hello, world!')<br /><br /><br />1Hello, world!<br /><br /><br />1print str(10000L)<br /><br /><br />110000<br /><br /><br />简而言之，str、repr是将Python值转换为字符串的2种方法。函数str让字符串更易于阅读，而repr则把结果字符串转换为合法的Python表达式。<br />11.4 input和raw_input的比较<br />1<br />2name=input('what is your name?')<br />print 'Hello, '+name+'!'<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25what is your name?Tom<br /><br /><br /><br />---------------------------------------------------------------------------<br /><br />NameError                                 Traceback (most recent call last)<br /><br /><ipython-input-1-46de911846e6> in <module>()<br />----> 1 name=input('what is your name?')<br />      2 print 'Hello, '+name+'!'<br /><br /><br />c:\\python27\\lib\\site-packages\\ipykernel\\ipkernel.pyc in <lambda>(prompt)<br />    139             self._sys_eval_input = builtin_mod.input<br />    140             builtin_mod.raw_input = self.raw_input<br />--> 141             builtin_mod.input = lambda prompt='': eval(self.raw_input(prompt))<br />    142         self._save_getpass = getpass.getpass<br />    143         getpass.getpass = self.getpass<br /><br /><br />c:\\python27\\lib\\site-packages\\ipykernel\\ipkernel.pyc in <module>()<br /><br /><br />NameError: name 'Tom' is not defined<br /><br /><br />问题在于input会假设用户输入的是合法的Python表达式。如果以字符串作为输入的名字，程序运行是没有问题的：<br />1<br />2name=input('what is your name?')<br />print 'Hello, '+name+'!'<br /><br /><br />1<br />2what is your name?'Tom'<br />Hello, Tom!<br /><br /><br />然而，要求用户带着引号输入他们的名字有点过分，因此，这就需要使用raw_input函数，它会把所有的输入当作原始数据，然后将其放入字符串中：<br />1<br />2name=raw_input('what is your name?')<br />print 'Hello, '+name+'!'<br /><br /><br />1<br />2what is your name?Tom<br />Hello, Tom!<br /><br /><br />除非对input有特别的需要，否则应该尽可能使用raw_input函数。 <br />11.5 原始字符串<br />普通字符串可以跨行。如果一行之中最后一个字符是反斜线，那么，换行符本身就被“转义”了，也就是被忽略了，例如：<br />1<br />2print 'hello, \\<br />world!'<br /><br /><br />1hello, world!<br /><br /><br />在普通字符串中，反斜线有特殊作用：它会转义，，可以在字符串中加入通常情况下不能直接加入的内容。例如，换行符可以写为\\n，并可放于字符串中，如下：<br />1print 'Hello,\\nworld!'<br /><br /><br />1<br />2Hello,<br />world!<br /><br /><br />这看起来不错，但是有时候，这并非是想要的结果。如果希望在字符串中包含反斜线再加上n怎么办？例如，像Windows路径”C:\\nowhere”这样的字符串：<br />1print 'C:\\nowhere'<br /><br /><br />1<br />2C:<br />owhere<br /><br /><br />这并不是期望的结果。那么该怎么办呢？可以使用反斜线对其本身进行转义：<br />1print 'C:\\\\nowhere'<br /><br /><br />1C:\\nowhere<br /><br /><br />这看起来不错，但是对于长路径，那么可能需要很多反斜线。在这样的情况下，原始字符串就派上用场了。原始字符串不会把反斜线当作特殊字符。在原始字符串中输入的每个字符都会与书写的方式保持一致：<br />1print r'C:\\nowhere'<br /><br /><br />1C:\\nowhere<br /><br /><br />可以看到，原始字符串以r开头。不能在原始字符串结尾输入反斜线。如果最后一个字符是反斜线，Python就不清楚是否应该结束字符串：<br />1print r'This is illegal\\'<br /><br /><br />1<br />2<br />3<br />4  File \"<ipython-input-10-f19bd253ec0b>\", line 1<br />    print r'This is illegal\\'<br />                            ^<br />SyntaxError: EOL while scanning string literal<br /><br /><br />12 小结<br />本章讲了很多内容。在继续下一章之前，先来回顾一下在本章学到了什么：","tags": "python basics 1","url": "blog/python_beginning/1begin.html"},
{"title": "对象","text": "<br />之前介绍了Python主要的内建对象类型（数字int、字符串str、列表list、元组tuple和字典dict），以及内建函数和标准库的用法，还有自定义函数的方式。接下来将介绍如何创建自己的对象？<br />为什么要自定义对象呢？使用字典、序列、数字和字符串来创建函数，完成这项工作还不够吗？这样做当然可以，但是创建自己的对象（尤其是类型或者被称为类的对象）是Python的核心概念，事实上，Python被称为面向对象的语言（和C++、Java一样）。接下来会介绍如何创建对象，以及多态、封装、方法、属性、父类以及继承的概念。<br />1 对象的魔力<br />对象可以看做数据（属性）以及一系列可以存取、操作这些数据的方法所组成的集合。使用对象替代全局变量和函数的原因可能有很多，其中对象最重要的优点如下：<br />1.1 多态<br />多态（Polymorphism）意味着就算不知道变量所引用的对象类型是什么，还是能对它进行操作，而它会根据对象（或类）类型的不同而表现出不同的行为。<br />1'abc'.count('a')<br /><br /><br />11<br /><br /><br />1[1,2,'a'].count('a')<br /><br /><br />11<br /><br /><br />对于变量x来说，不需要知道它是字符串还是列表，就可以调用它的count方法—不用管它是什么类型（只要提供一个字符作为参数即可）。  <br />任何不知道对象到底是什么类型，但是又要对对象“做点什么”的时候，都会用到多态。这不仅限于方法，很多内建运算符和函数都有多态的性质：<br />11+2<br /><br /><br />13<br /><br /><br />1'Fish '+'license'<br /><br /><br />1'Fish license'<br /><br /><br />1.2 封装<br />封装是可以不关心对象是如何构建的而直接进行使用。如何将变量“封装”在对象内？可以将其作为属性（attribute）存储。正如方法一样，属性是对象内部的变量。  <br />对象有它自己的状态（state），对象的状态由它的属性（比如名称）来描述。对象的方法可以改变它的属性。<br />1.3 继承<br />如果已经有了一个类，而又想建立一个非常类似的呢？新的类可能只是添加几个方法。这时就会用到继承。<br />2 类和类型<br />类将它视为种类或类型的同义词，代表对象的集合。类的主要任务是定义它的实例会用到的方法。所有的对象都属于某一个类，称为类的实例。当一个对象所属的类是另外一个对象所属类的子集时，前者就被称为后者的子类（subclass），所以“百灵鸟类”是“鸟类”的子类。相反，“鸟类”是“百灵鸟类”的父类（superclass）。    <br />Python中，习惯上使用单数名词，并且首字母大写，比如Bird和Lark，来描述对象的类。<br />2.1 创建自己的类<br />先来看一个简单的类：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11__metaclass__=type   #确定使用新式类<br />class Person:<br />    def setName(self, name):<br />        self.name=name<br />    def getName(self):<br />        return self.name<br />    def greet(self):<br />        print \"Hello, world! I'm % s\" %  self.name<br />foo=Person()<br />foo.setName('Luke Skywalker')<br />foo.greet()<br /><br /><br />1Hello, world! I'm Luke Skywalker<br /><br /><br />注意 尽管可能使用的是新版的Python，但一些功能不会在旧式类上起作用。为了确保类是新型的，需要在模块或者脚本开始的地方放置赋值语句__metaclass__=type，或者继承新式类（比如object类，也就是子类化内建类object）。新式类必然包含了更多的功能，也是之后推荐的写法，从写法上区分的话，如果当前类或者父类继承了object类，那么该类便是新式类。<br />在调用foo的setName和greet函数时，foo自动将自己作为第一个参数传人函数中—因此形象地命名为self。显然这就是self的用处和存在的必要性。没有它，成员方法就没法访问它们要对其属性进行操作的对象本身了。  <br />属性是可以在外部访问的：<br />1foo.name<br /><br /><br />1'Luke Skywalker'<br /><br /><br />2.2 属性和方法<br />self参数事实上正是方法和函数的区别。方法将它们的第一个参数绑定到所属的实例上，因此这个参数可以不必提供。   <br />属性只是作为对象的一部分变量，方法则是存储在对象内的函数。<br />2.2.1 私有化 <br />默认情况下，程序可以从外部访问一个对象的属性。但是有时候需要使用私有属性，这是外部对象无法访问的，但是通过getName和setName等访问器（accessor）能够访问这些私有属性。<br />为了让方法或者属性变为私有，只要在它的名字前面加上双下划线即可：<br />1<br />2<br />3<br />4<br />5<br />6class Secretive:<br />    def __inaccessible(self):<br />        print \"Hello, world!\"<br />    def accessible(self):<br />        print \"The secret message is: \"<br />        self.__inaccessible()<br /><br /><br />现在__inaccessible从外界是无法访问的，而在内部还能使用(比如从accessible)访问：<br />1<br />2s=Secretive()<br />s.__inaccessible()<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10---------------------------------------------------------------------------<br /><br />AttributeError                            Traceback (most recent call last)<br /><br /><ipython-input-4-ffe7eb44855c> in <module>()<br />      1 s=Secretive()<br />----> 2 s.__inaccessible()<br /><br /><br />AttributeError: Secretive instance has no attribute '__inaccessible'<br /><br /><br />1s.accessible()<br /><br /><br />1<br />2The secret message is: <br />Hello, world!<br /><br /><br />类的内部定义中，所有以双下划线开始的名字（方法或属性）都被“翻译”成前面加上单下划线和类名的形式。在了解了这些幕后的事情后，实际上还是能在类外访问这些私有方法，尽管不应该这么做：<br />1s._Secretive__inaccessible()<br /><br /><br />1Hello, world!<br /><br /><br />简而言之，确保其他人不会访问对象的方法和属性是不可能的，但是通过这类“名称变化术”就是他们不应该访问这些方法和属性的强有力信号。<br />2.2.2 访问器方法 <br />访问器是一个简单的方法，它能使用getHeight、setHeight这样的名字来得到或者重绑定一些属性：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12class Rectangle:<br />    def __inf__(self):<br />        self.width=0<br />        self.height=0<br />    def setSize(self,size):<br />        self.width,self.height=size<br />    def getSize(self):<br />        return self.width,self.height<br />r=Rectangle()<br />r.width=10<br />r.height=5<br />r.getSize()<br /><br /><br />1(10, 5)<br /><br /><br />1<br />2r.setSize((150,100))<br />r.width<br /><br /><br />1150<br /><br /><br />在上面的例子中，getSize和setSize方法是一个名为size的假想属性的访问器方法，size是由width和height构成的元组。如果有一天要改变类的实现，将size变成一个真正的属性，这样width和height就可以动态算出，那么就要把它们放到一个访问器方法中去。但如果有很多简单的属性，那么就不现实了。如果那么做就得写很多访问器方法。那么怎么解决呢？这就需要用到property函数。   <br />property函数 <br />property函数的使用很简单。延续上面的Rectangle类，只要增加一行代码（子类化object，或者使用__metaclass__=type）:<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10__metaclass__=type<br />class Rectangle:<br />    def __inf__(self):<br />        self.width=0<br />        self.height=0<br />    def setSize(self,size):<br />        self.width,self.height=size<br />    def getSize(self):<br />        return self.width,self.height<br />    size=property(getSize,setSize)<br /><br /><br />在新版的Rectangle中，property函数创建了一个属性size，其中访问器方法被当做参数（先是取值，然后是赋值）。<br />1<br />2<br />3<br />4w=Rectangle()<br />w.width=10<br />w.height=5<br />w.size<br /><br /><br />1(10, 5)<br /><br /><br />1<br />2w.size=150,100<br />w.width<br /><br /><br />1150<br /><br /><br />很显然，size属性仍然取决于getSize和setSize中的计算。但它看起来就像普通的属性一样。实际上，property函数可以用fget，fset，fdel和doc-这四个参数来调用。如果没有参数，产生的属性既不可读，也不可写。如果只使用一个参数调用（一个取值方法），产生的属性是只读的。第三个参数（可选）是一个用于删除属性的方法。第四个参数（可选）是一个文档字符串。<br />2.2.3 特殊方法 <br />在Python中，有的名称（方法名）在前面和后面都加上两个下划线，比如__future__，这样拼写表示名字有特殊含义，所以绝不要在自己的程序中使用这种名字。由这些名字组成的集合所包含的方法称为特殊方法。如果对象实现了这些方法的某一个，那么这个方法会在特殊的情况下被Python调用。而几乎没有直接调用它们的必要。<br />(1) 构造方法<br />首先要讨论的第一个特殊方法是构造方法。构造方法是一个很奇怪的名字，它代表着类似于以前例子中使用过的那种名为init的初始化方法。但构造方法和其他普通方法不同的地方在于，当一个对象被创建后，会立即调用构造方法。<br />1<br />2<br />3<br />4<br />5class FooBar:<br />    def __init__(self):<br />        self.somevar=42<br />f=FooBar()<br />f.somevar<br /><br /><br />142<br /><br /><br />(2) 重写一般方法和特殊的构造方法 <br />如果一个方法在B类的一个实例中被调用（或一个属性被访问），但在B类中没有找到该方法，那么就会去它的父类A里面找：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8class A:<br />    def hello(self):<br />        print \"hello, I'm A\"<br />class B(A):<br />    pass<br />a=A()<br />b=B()<br />a.hello()<br /><br /><br />1hello, I'm A<br /><br /><br />1b.hello()<br /><br /><br />1hello, I'm A<br /><br /><br />在子类中增加功能最基本的方式就是增加方法。但是也可以重写一些父类的方法来自定义继承的行为。B类也能重写这个方法。<br />1<br />2<br />3<br />4<br />5class B(A):<br />    def hello(self):<br />        print \"hello, I'm B\"<br />b=B()<br />b.hello()  <br /><br /><br />1hello, I'm B<br /><br /><br />重写是继承机制中的一个重要内容，但是对于构造方法尤其重要。构造方法用来初始化新创建对象的状态，大多数子类不仅要拥有自己的初始化代码，还要拥有父类的初始化代码。虽然重写的机制对于所有方法来说都是一样的，但是当重写构造方法时，更可能遇到特别的问题：如果一个类的构造方法被重写，那么就需要调用父类的构造方法，否则对象可能不会被正确的初始化。如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11class Bird:<br />    def __init__(self):<br />        self.hungry=True<br />    def eat(self):<br />        if self.hungry:<br />            print 'Aaaah...'<br />            self.hungry=False<br />        else:<br />            print 'No,thanks!'<br />b=Bird()<br />b.eat()<br /><br /><br />1Aaaah...<br /><br /><br />1b.eat()<br /><br /><br />1No,thanks!<br /><br /><br />可以看到，鸟吃过了以后，就不会再饥饿。现在考虑子类SongBird，它添加了唱歌的行为。<br />1<br />2<br />3<br />4<br />5<br />6<br />7class SongBird(Bird):<br />    def __init__(self):<br />        self.sound='Squawk!'<br />    def sing(self):<br />        print self.sound<br />sb=SongBird()<br />sb.sing()<br /><br /><br />1Squawk!<br /><br /><br />因为SongBird是Bird的一个子类，它继承了eat方法，但如果调用eat方法，就会产生一个问题：<br />1sb.eat()<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17---------------------------------------------------------------------------<br /><br />AttributeError                            Traceback (most recent call last)<br /><br /><ipython-input-19-05f67b3cf162> in <module>()<br />----> 1 sb.eat()<br /><br /><br /><ipython-input-14-d86c7aaa626a> in eat(self)<br />      3         self.hungry=True<br />      4     def eat(self):<br />----> 5         if self.hungry:<br />      6             print 'Aaaah...'<br />      7             self.hungry=False<br /><br /><br />AttributeError: SongBird instance has no attribute 'hungry'<br /><br /><br />异常很清楚地说明了错误：SongBird没有hungry属性。原因是：在SongBird中，构造方法被重写，但新的构造方法没有任何关于初始化hungry属性的代码。为了达到预期的效果，SongBird的构造方法必须调用其父类Bird的构造方法来确保进行基本的初始化。有两种方法能达到这个目的，如下： <br />调用未绑定的父类构造方法<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8class SongBird(Bird):<br />    def __init__(self):<br />        Bird.__init__(self)<br />        self.sound='Squawk!'<br />    def sing(self):<br />        print self.sound<br />sb=SongBird()<br />sb.sing()<br /><br /><br />1Squawk!<br /><br /><br />1sb.eat()<br /><br /><br />1Aaaah...<br /><br /><br />1sb.eat()<br /><br /><br />1No,thanks!<br /><br /><br />通过将当前的实例作为self参数提供给未绑定方法，SongBird就能够使用其父类构造方法的所有实现，也就是说属性hungry能被设置。<br />使用super函数 <br />super函数只能在新式类中使用。当前的类和对象可以作为super函数的参数使用，调用函数返回的是父类的方法，而不是当前类的方法。如下：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9__metaclass__=type<br />class SongBird(Bird):<br />    def __init__(self):<br />        super(SongBird,self).__init__()<br />        self.sound='Squawk!'<br />    def sing(self):<br />        print self.sound<br />sb=SongBird()<br />sb.sing()<br /><br /><br />1Squawk!<br /><br /><br />1sb.eat()<br /><br /><br />1Aaaah...<br /><br /><br />1sb.eat()<br /><br /><br />1No,thanks!<br /><br /><br />(3) 成员访问方法<br />接下来介绍一些处理对象访问的方法，这些方法允许你创建自己的序列或者映射。   <br />基本的序列和映射规则很简单，但如果要实现它们全部功能就需要实现很多特殊函数。下面将会说到：<br />基本的序列和映射规则 <br />序列和映射是对象的集合。为了实现它们基本的行为（规则），如果对象是不可变的（如字符串和元组）。那么就需要使用两个特殊方法，如果是可变的（列表和字典），则需要使用4个。<br />a. __len__(self):这个方法返回集合中所含对象的数量。对于序列来说，这就是元素的个数；对于映射来说，则是键-值对的数量。<br />b. __getitem__(self,key):这个方法返回与所给键对应的值。对于序列来说，键应该是一个0~n-1的整数（或者像后面所说的负数）；对于映射来说，可以使用任何种类的键。<br />c. __setitem__(self,key,value):这个方法按一定的方式存储和key关联的value，该值随后可使用 __getitem__来获取。当然，只能为可以修改的对象定义这个方法。<br />d. __delitem__(self,key):这个方法在对一部分对象使用del语句时被调用，同时删除和键关联的值。这个方法也是为可修改的对象定义的。     <br />对这些方法的附件要求：   <br />a. 对于一个序列来说，如果键是负整数，那么要从末尾开始计数。换句话说就是x[-n]和x[len(x)-n]是一样的；  <br />b. 如果键是不合适的类型（例如，对序列使用字符串作为键），会引发一个TypeError异常;    <br />c. 如果序列的索引是正确的类型，但超出了范围，会引发一个IndexError异常。   <br />让我们实践一下—看看如果创建一个无穷序列，会发生什么：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34def checkIndex(key):<br />    \"\"\"所给的键能接受索引吗？<br />    为了能被接受，键应该是一个非负的整数，如果它不是一个整数，比如是字符串，会引发TypeError;<br />    如果它是负数，则会引发IndexError（因为序列是无限长的）。<br />    \"\"\"<br />    if not isinstance(key,(int,long)):<br />        raise TypeError<br />    if key<0:<br />        raise IndexError<br />class ArithmeticSequence:<br />    def __init__(self,start=0,step=1):<br />        \"\"\"初始化算数序列<br />        初始值-序列中的第一个值<br />        步长-两个相邻值之间的差别<br />        改变-用户修改的值的字典<br />        \"\"\"<br />        self.start=start<br />        self.step=step<br />        self.changed={}  #没有项被修改<br />    def __getitem__(self,key):<br />        \"\"\"Get an item from the arithmetic sequence.<br />        \"\"\"<br />        checkIndex(key)<br />        try:<br />            return self.changed[key]             #修改了吗？<br />        except KeyError:                         #否则...<br />            return self.start+key*self.step      #...计算值<br />    def __setitem__(self,key,value):<br />        \"\"\"修改算术序列中的一个项<br />        \"\"\"<br />        checkIndex(key)<br />        self.changed[key]=value<br />s=ArithmeticSequence(1,2)<br />s[4]<br /><br /><br />19<br /><br /><br />1<br />2s[4]=2<br />s[4]<br /><br /><br />12<br /><br /><br />1s[5]<br /><br /><br />111<br /><br /><br />注意，没有实现__del__方法的原因是我希望删除元素是非法的：<br />1del s[4]<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9---------------------------------------------------------------------------<br /><br />AttributeError                            Traceback (most recent call last)<br /><br /><ipython-input-6-9cf88d1604ce> in <module>()<br />----> 1 del s[4]<br /><br /><br />AttributeError: ArithmeticSequence instance has no attribute '__delitem__'<br /><br /><br />这个类没有__len__方法，因为它是无限长的。   <br />索引检查是通过用户自定义的checkIndex函数实现的。如果使用了一个非法类型的索引，就会引发TypeError异常，如果索引的类型是正确的但超出了范围，则会引起IndexError异常：<br />1s['four']<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25---------------------------------------------------------------------------<br /><br />TypeError                                 Traceback (most recent call last)<br /><br /><ipython-input-7-f34801bc947b> in <module>()<br />----> 1 s['four']<br /><br /><br /><ipython-input-3-6350fc4de34b> in __getitem__(self, key)<br />     21         \"\"\"Get an item from the arithmetic sequence.<br />     22         \"\"\"<br />---> 23         checkIndex(key)<br />     24         try:<br />     25             return self.changed[key]             #修改了吗？<br /><br /><br /><ipython-input-3-6350fc4de34b> in checkIndex(key)<br />      5     \"\"\"<br />      6     if not isinstance(key,(int,long)):<br />----> 7         raise TypeError<br />      8     if key<0:<br />      9         raise IndexError<br /><br /><br />TypeError:<br /><br /><br />1s[-4]<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25---------------------------------------------------------------------------<br /><br />IndexError                                Traceback (most recent call last)<br /><br /><ipython-input-8-d1e9953ed446> in <module>()<br />----> 1 s[-4]<br /><br /><br /><ipython-input-3-6350fc4de34b> in __getitem__(self, key)<br />     21         \"\"\"Get an item from the arithmetic sequence.<br />     22         \"\"\"<br />---> 23         checkIndex(key)<br />     24         try:<br />     25             return self.changed[key]             #修改了吗？<br /><br /><br /><ipython-input-3-6350fc4de34b> in checkIndex(key)<br />      7         raise TypeError<br />      8     if key<0:<br />----> 9         raise IndexError<br />     10 class ArithmeticSequence:<br />     11     def __init__(self,start=0,step=1):<br /><br /><br />IndexError:<br /><br /><br />(4) __getattr__和__setattr__ <br />拦截（intercept）对象的所有属性访问是可能的，这样可以用旧式类实现属性。为了在访问属性的时候可以执行代码，必须使用一些特殊方法。下面的4种方法提供了需要的功能（在旧式类中只需要后3个）<br />a. __getattribute__(self,name):当属性name被访问时自动被调用（只能在新式类中使用）；<br />b. __getattr__(self,name):当属性name被访问且对象没有相应的属性时被自动调用；<br />c. __setattr__(self,name,value): 当试图给属性name赋值时会被自动调用；<br />d. __delattr__(self,name): 当试图删除属性name时会被自动调用。<br />尽管和使用property函数相比有点复杂（而且在某些方面效率更低），但是这些特殊方法是很强大的，因为可以对处理很多属性的方法进行再编码。   <br />下面还是Rectangle的例子，但这次使用的是特殊方法：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14class Rectangle:<br />    def __init__(self):<br />        self.width=0<br />        self.height=0<br />    def __setattr__(self,name,value):<br />        if name =='size':<br />            self.width,self.height=value<br />        else:<br />            self.__dict__[name]=value<br />    def __getattr__(self,name):<br />        if name =='size':<br />            return self.width,self.height<br />        else:<br />            raise AttributeError<br /><br /><br />1<br />2w=Rectangle()<br />w.size<br /><br /><br />1(0, 0)<br /><br /><br />1w.__dict__<br /><br /><br />1{'height': 0, 'width': 0}<br /><br /><br />1<br />2w.size=(2,6)<br />w.size<br /><br /><br />1(2, 6)<br /><br /><br />1w.width<br /><br /><br />12<br /><br /><br />1hasattr(w,'size')<br /><br /><br />1True<br /><br /><br />1<br />2w.age=28<br />w.age<br /><br /><br />128<br /><br /><br />1w.__dict__<br /><br /><br />1{'age': 28, 'height': 6, 'width': 2}<br /><br /><br />注意： __setattr__方法在所涉及的属性不是size时也会被调用。如果属性是size，那么就像前面那样执行操作，否则就要使用特殊方法__dict__，该方法包含一个字典，字典里是所有实例的属性；   <br />__getattr__方法只在普通的属性没有被找到的时候调用。<br />(5) 迭代器 <br />迭代的意思是重复做一些事很多次—就像在循环中做的那样。到现在为止只有在for循环中对序列和字典进行迭代，但实际上也能对其他的对象进行迭代：实现__iter__特殊方法的对象。   <br />__iter__方法返回一个迭代器（iterator），所谓的迭代器就是具有next方法（这个方法在调用时不需要任何参数）的对象。在调用next方法时，迭代器会返回它的下一个值。     <br />迭代规则的关键是什么？为什么不使用列表？因为列表的杀伤力太大。如果有可以一个接一个地计算值的函数，那么在使用时可能是计算一个值时获取一个值-而不是通过列表一次性获取所有值。如果有很多值，列表就会占用太多的内存。另外，使用迭代器更通用、更简单、更优雅。让我们看看一个不使用列表的例子，因为要用的话，列表的长度必须无限。    <br />这里的“列表”是一个斐波那契数列。使用的迭代器如下：   <br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14class Fibs:<br />    def __init__(self):<br />        self.a=0<br />        self.b=1<br />    def next(self):<br />        self.a,self.b=self.b,self.a+self.b<br />        return self.a<br />    def __iter__(self):<br />        return self<br />fibs=Fibs()<br />for f in fibs:<br />    if f>10:<br />        print f<br />        break<br /><br /><br />113<br /><br /><br />在很多情况下，__iter__被放到会在for循环中使用的对象中。  <br />注意 正式的说法是，一个实现了__iter__方法的对象是可迭代的，一个实现了next方法的对象则是迭代器。    <br />内建函数iter可以从可迭代的对象中获得迭代器：<br />1<br />2a=[1,2,3]<br />a.next()<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10---------------------------------------------------------------------------<br /><br />AttributeError                            Traceback (most recent call last)<br /><br /><ipython-input-86-9cc7ef1283fa> in <module>()<br />      1 a=[1,2,3]<br />----> 2 a.next()<br /><br /><br />AttributeError: 'list' object has no attribute 'next'<br /><br /><br />1<br />2it=iter([1,2,3])<br />it.next()<br /><br /><br />11<br /><br /><br />1it.next()<br /><br /><br />12<br /><br /><br />从迭代器中得到序列： <br />使用list函数显式地将迭代器转化为列表。<br />1<br />2it=iter([1,2,3])<br />it<br /><br /><br />1<listiterator at 0x43e8978><br /><br /><br />1list(it)<br /><br /><br />1[1, 2, 3]<br /><br /><br />2.3 类的命名空间<br />所有位于class语句中的代码都在特殊的命名空间中执行—类命名空间。这个命名空间可由类内所有成员访问。<br />1<br />2class C:<br />    print 'Class C being defined...'<br /><br /><br />1Class C being defined...<br /><br /><br />从上可以看出，类的定义其实就是执行代码块，这一点很有用，比如，在类的定义区并不只限使用def语句：<br />1<br />2<br />3<br />4<br />5<br />6<br />7class MemberCounter:<br />    members=0<br />    def init(self):<br />        MemberCounter.members+=1<br />m1=MemberCounter()<br />m1.init()<br />MemberCounter.members<br /><br /><br />11<br /><br /><br />1<br />2<br />3m2=MemberCounter()<br />m2.init()<br />MemberCounter.members<br /><br /><br />12<br /><br /><br />上面的代码中，在类作用域内定义了一个可供所有成员（实例）访问的变量，用来计算类的成员数量。  <br />就像方法一样，类作用域内的变量也可以被所有实例（对象）访问：<br />1m1.members<br /><br /><br />12<br /><br /><br />1m2.members<br /><br /><br />12<br /><br /><br />那么在实例中重绑定members属性呢？<br />1<br />2m1.members='Two'<br />m1.members<br /><br /><br />1'Two'<br /><br /><br />1m2.members<br /><br /><br />12<br /><br /><br />2.4 继承父类<br />子类可以扩展父类的定义。将其他类名写在class语句后的圆括号内就可以继承父类：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8class Filter:<br />    def init(self):<br />        self.blocked=[]<br />    def filter(self,sequence):<br />        return [x for x in sequence if x not in self.blocked]<br />class SPAMFilter(Filter):<br />    def init(self):<br />        self.blocked=['SPAM']<br /><br /><br />1<br />2<br />3f=Filter()<br />f.init()<br />f.filter([1,2,3])<br /><br /><br />1[1, 2, 3]<br /><br /><br />Filter类的用处在于它可以用作其他类的父类，比如SPAMFilter类，可以将序列中“SPAM”过滤出去。<br />1<br />2<br />3s=SPAMFilter()<br />s.init()<br />s.filter(['SPAM','SPAM','SPAM','SPAM','eggs','bacon'])<br /><br /><br />1['eggs', 'bacon']<br /><br /><br />2.4.1 子类化列表，字典和字符串 <br />如果希望实现一个和内建对象类型（例如列表，字符串和字典）行为相似的序列或映射，可以使用子类化内建类型。   <br />注意 当子类化一个内建类型，比如list的时候，也就间接的将object子类化了。因此该类就自动成为新式类，意味着可以使用像super函数这样的特性了。    <br />看看下面的例子-带有访问计数的列表。<br />1<br />2<br />3<br />4<br />5<br />6<br />7class CounterList(list):<br />    def __init__(self,*args):<br />        super(CounterList,self).__init__(*args)<br />        self.counter=0<br />    def __getitem__(self,index):<br />        self.counter+=1<br />        return  super(CounterList,self).__getitem__(index)<br /><br /><br />CounterList类严重依赖于它的子类化父类（list）的行为。CounterList类没有重写任何的方法，能直接调用列表的任何方法（如append、extend、index）。在两个被重写的方法中，super方法被用来调用相应的父类的方法，只有在__init__中添加了所需的初始化counter属性的行为，并在__getitem__中更新了counter属性。<br />1<br />2c1=CounterList('aaa')<br />c1<br /><br /><br />1['a', 'a', 'a']<br /><br /><br />1<br />2c1=CounterList((1,2,3))<br />c1<br /><br /><br />1[1, 2, 3]<br /><br /><br />1<br />2c1=CounterList({'first':1,'second':2})<br />c1<br /><br /><br />1['second', 'first']<br /><br /><br />1<br />2c1=CounterList(range(10))<br />c1<br /><br /><br />1[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br /><br /><br />1<br />2c1.reverse()<br />c1<br /><br /><br />1[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]<br /><br /><br />1<br />2del c1[3:6]<br />c1<br /><br /><br />1[9, 8, 7, 3, 2, 1, 0]<br /><br /><br />1c1.counter<br /><br /><br />10<br /><br /><br />1c1[0]+c1[1]+c1[2]<br /><br /><br />124<br /><br /><br />1c1.counter<br /><br /><br />13<br /><br /><br />可以看到，CounterList在很多方面和列表的作用一样，但它有一个counter属性（被初始化为0），每次列表元素被访问时，它都会自增。<br />2.5 调查继承<br />如果想要查看一个类是否是另一个的子类，可以使用内建的issubclass函数：<br />1issubclass(SPAMFilter,Filter)<br /><br /><br />1True<br /><br /><br />1issubclass(Filter,SPAMFilter)<br /><br /><br />1False<br /><br /><br />如果想要知道已知类的父类(们)，可以直接使用它的特殊属性__bases__：<br />1SPAMFilter.__bases__<br /><br /><br />1(<class __main__.Filter at 0x00000000041247C8>,)<br /><br /><br />1Filter.__bases__<br /><br /><br />1()<br /><br /><br />同样，还能使用isinstance函数检测一个对象是否是一个类的实例：<br />1<br />2s=SPAMFilter()<br />isinstance(s,SPAMFilter)<br /><br /><br />1True<br /><br /><br />1isinstance(s,str)<br /><br /><br />1False<br /><br /><br />如果只想知道一个对象属于哪个类，可以使用__class__属性或type函数：<br />1s.__class__<br /><br /><br />1<class __main__.SPAMFilter at 0x00000000042657C8><br /><br /><br />1type(s)<br /><br /><br />1__main__.SPAMFilter<br /><br /><br />1type([1,2])<br /><br /><br />1list<br /><br /><br />2.6 多个父类<br />一个类的父类可能多于一个，如下：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8class Calculator:<br />    def calculate(self,expression):<br />        self.value=eval(expression)<br />class Talker:<br />    def talk(self):<br />        print 'Hi,my value is ',self.value<br />class TalkingCalculator(Calculator,Talker):<br />    pass<br /><br /><br />子类（TalkingCalculator）自己不做任何事，它从自己的父类继承所有的行为。这样它就成了会说话的计算器（talking calculator）。<br />1<br />2<br />3tc=TalkingCalculator()<br />tc.calculate('1+2+3')<br />tc.talk()<br /><br /><br />1Hi,my value is  6<br /><br /><br />这种行为称为多重继承（multiple inheritance），是个非常有用的工具。   <br />一般来说，对于对象不用探讨过深。程序员可以靠多态调用自己需要的方法。不过如果想要知道对象到底有什么方法和属性，有些函数可以帮助完成这项工作。如下可以检查对象的方法或属性是否已经存在：<br />1hasattr(tc,'talk')<br /><br /><br />1True<br /><br /><br />1hasattr(tc,'fnord')<br /><br /><br />1False<br /><br /><br />1getattr(tc,'talk','None')   #获得对象属性的值，可选择提供默认值，以便在属性不存在时使用<br /><br /><br />1<bound method TalkingCalculator.talk of <__main__.TalkingCalculator instance at 0x0000000004379E08>><br /><br /><br />1getattr(tc,'value','None')<br /><br /><br />16<br /><br /><br />1<br />2setattr(tc,'name','Mr. Gumby')   #与getattr相对应的函数是setattr，用来设置对象的属性及值<br />tc.name<br /><br /><br />1'Mr. Gumby'<br /><br /><br />如果要查看对象内所有存储的值，那么可以使用__dict__属性。<br />1tc.__dict__<br /><br /><br />1{'name': 'Mr. Gumby', 'value': 6}<br /><br /><br />3 生成器<br />生成器是Python新引入的概念。生成器是一种普遍的函数语法定义的迭代器。接下来介绍怎么创建和使用生成器，了解它的内部机制。<br />3.1 创建生成器<br />创建一个生成器就像创建函数一样简单。首先我们创建一个可以展开嵌套列表的函数。参数是一个列表：<br />1<br />2<br />3<br />4<br />5def flatten(nested):<br />    for sublist in nested:<br />        for element in sublist:<br />            yield element<br />nested=[[1,2],[3,4],5]<br /><br /><br />任何包含yield语句的函数称为生成器。除了名字不同以外，它的行为和普通的函数也有很大的差别。这就在于它不像return语句那样返回值，而是每次产生一个值。每次产生一个值（使用yield语句），函数就会被冻结：即函数停在那点等待被激活。函数被激活后就从停止的那点开始执行。   <br />接下来可以通过在生成器上迭代来使用所有的值：<br />1flatten(nested)<br /><br /><br />1<generator object flatten at 0x00000000043F3EE8><br /><br /><br />1<br />2for num in flatten(nested):<br />    print num<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />251<br />2<br />3<br />4<br /><br /><br /><br />---------------------------------------------------------------------------<br /><br />TypeError                                 Traceback (most recent call last)<br /><br /><ipython-input-119-b385b8be1106> in <module>()<br />----> 1 for num in flatten(nested):<br />      2     print num<br /><br /><br /><ipython-input-116-d7d394ff2981> in flatten(nested)<br />      1 def flatten(nested):<br />      2     for sublist in nested:<br />----> 3         for element in sublist:<br />      4             yield element<br />      5 nested=[[1,2],[3,4],5]<br /><br /><br />TypeError: 'int' object is not iterable<br /><br /><br />从上可以看到，试图对一个数值5进行迭代会引发一个TypeError异常。   <br />生成器由两部分组成：生成器的函数和生成器的迭代器。生成器的函数是用def语句定义的，包含yield部分，生成器的迭代器是这个函数返回的部分。<br />1nested=[[1,2],[3,4],[5]]<br /><br /><br />1list(flatten(nested))<br /><br /><br />1[1, 2, 3, 4, 5]<br /><br /><br />3.2 递归生成器<br />如果要处理任意层的嵌套该怎么办？每次嵌套需要增加一个for循环，但因为不知道有几层嵌套，所以必须把解决方案变得更灵活。这就需要用到递归：<br />1<br />2<br />3<br />4<br />5<br />6<br />7def flatten(nested):<br />    try:<br />        for sublist in nested:<br />            for element in flatten(sublist):<br />                yield element<br />    except TypeError:<br />        yield nested<br /><br /><br />当flatten被调用时，有两种可能性（处理递归时大部分都是这种情况）：基本情况和需要递归的情况。在基本的情况中，函数被告知展开一个元素（比如一个数字），这种情况下，for循环会引发一个TypeError异常（因为试图对一个数字进行迭代），生成器会产生一个元素。如果展开的是一个列表，那么就要进行特殊处理。程序必须遍历所有的子列表，并对他们调用flatten。然后使用另一个for循环来产生被展开的子列表的所有元素。<br />1list(flatten([[[1],2],3,4,[5,[6,7]],8]))<br /><br /><br />1[1, 2, 3, 4, 5, 6, 7, 8]<br /><br /><br />到目前为止，Python语言的大部分知识都介绍了。","tags": "python 多态 封装 方法 5","url": "blog/python_beginning/5object.html"},
{"title": "建议箱","text": "欢迎大家对本网站的内容提出宝贵的建议","tags": "建议","url": "blog/suggestion_box.html"},
{"title": "数据结构","text": "<br />数据结构是通过某种方式（例如对元素进行编号）组织在一起的数据元素的集合。在Python中，最基本的数据结构是序列(sequence)。序列中每个元素被分配一个序号-即元素的位置，也称为索引。第一个索引是0。Python中包含6种内建的序列，最常用的类型是：列表、元组和字符串。列表和元组/字符串的主要区别在于，列表可以修改，元组/字符串则不能。一般来说，在几乎所有的情况下列表都可以替代元组。<br />1 通用序列操作<br />所有序列类型都可以进行某些特定的操作，包括：索引（indexing）、分片（sliceing）、加（adding）、乘（multiplying）以及检查某个元素是否属于序列的成员。除此之外，Python还有计算序列长度、找出最大元素和最小元素的内建函数。<br />1.1 索引<br />序列中所有元素都有编号（索引）-从0开始递增。这些元素可以通过索引进行访问，如下：<br />1<br />2greet='hello'<br />greet[0]<br /><br /><br />1'h'<br /><br /><br />1greet[-1]<br /><br /><br />1'o'<br /><br /><br />使用负数索引时，Python会从右边，也就是从最后1个元素开始计数。最后1个元素的位置编号是-1。<br />1.2 分片<br />使用分片操作来访问一定范围内的元素。分片可通过冒号相隔两个索引来实现，如下：<br />1<br />2greet='hello, world！'<br />greet[1:8]<br /><br /><br />1'ello, w'<br /><br /><br />1<br />2nunbers=[1,2,3,4,5,6,7,8]<br />nunbers[3:6]<br /><br /><br />1[4, 5, 6]<br /><br /><br />1nunbers[-3:-1]<br /><br /><br />1[6, 7]<br /><br /><br />1nunbers[-3:]<br /><br /><br />1[6, 7, 8]<br /><br /><br />分片操作的实现需要提供两个索引作为边界，第1个索引的元素是包含在分片内的，而第2个则不包含在分片内。<br />1nunbers[0:6:2]<br /><br /><br />1[1, 3, 5]<br /><br /><br />在这个例子中，分片包含了另外一个数字，这就是步长的显示设置。步长为2的分片包括的是从开始到结束每隔1个的元素。步长可以是负数，从右到左提取元素：<br />1nunbers[7:3:-2]<br /><br /><br />1[8, 6]<br /><br /><br />1.3 序列相加<br />使用加号可以进行序列的连接操作：<br />1[1,2,3]+[4,5,6]<br /><br /><br />1[1, 2, 3, 4, 5, 6]<br /><br /><br />1'hello, '+'world!'<br /><br /><br />1'hello, world!'<br /><br /><br />1.4 乘法<br />用数字x乘以一个序列会生成新的序列，而在新序列中，原来的序列被重复x次：<br />1'python'*5<br /><br /><br />1'pythonpythonpythonpythonpython'<br /><br /><br />1[12]*3<br /><br /><br />1[12, 12, 12]<br /><br /><br />1[None]*10<br /><br /><br />1[None, None, None, None, None, None, None, None, None, None]<br /><br /><br />有时候可能会需要一个值来代表空值，这个时候就需要使用None。None是一个Python的内建值，它确切含义是“这里什么也没有”。<br />1.5 成员资格<br />为了检测一个值是否在序列中，可以使用in运算符（布尔运算符）。<br />1'a' in 'hello'<br /><br /><br />1False<br /><br /><br />1'e' in 'hello'<br /><br /><br />1True<br /><br /><br />1.6 长度、最小值和最大值<br />内建函数len、min和max很有用。<br />1<br />2numbers=[1,2,3]<br />len(numbers)<br /><br /><br />13<br /><br /><br />1max(numbers)<br /><br /><br />13<br /><br /><br />2 列表<br />接下来讨论列表不同于元组和字符串的地方：列表是可变的-可以改变列表的内容，并且列表有很多有用的、专门的方法。<br />2.1 list函数<br />因为字符串不能像列表一样被修改，所以有时根据字符串创建列表会很有用。list函数可以实现这个操作。<br />1list('hello')<br /><br /><br />1['h', 'e', 'l', 'l', 'o']<br /><br /><br />可以用下面的表达式将一个由字符组成的列表转换为字符串：<br />1''.join(['h', 'e', 'l', 'l', 'o'])<br /><br /><br />1'hello'<br /><br /><br />2.2 基本的列表操作<br />列表可以使用所有适用于序列的标准操作，如索引、分片和连接等。接下来会介绍一些可以改变列表的方法。<br />改变列表：元素赋值 <br />使用索引标记来为某个特定的、位置明确的元素赋值，如下：<br />1<br />2<br />3x=[1,1,1]<br />x[1]=2<br />x<br /><br /><br />1[1, 2, 1]<br /><br /><br />删除元素 <br />使用del语句来实现<br />1<br />2del x[1]<br />x<br /><br /><br />1[1, 1]<br /><br /><br />分片赋值<br />分片是一个非常强大的特性，分片赋值操作则更加显示它的强大。<br />1<br />2name=list('Perl')<br />name<br /><br /><br />1['P', 'e', 'r', 'l']<br /><br /><br />1<br />2name[2:]=list('ar')<br />name<br /><br /><br />1['P', 'e', 'a', 'r']<br /><br /><br />2.3 列表方法<br />方法是一个与某些对象有紧密联系的函数。对象可能是列表、数字，也可能是字符串或者其他类型的对象。方法可以这样进行调用：   <br />对象.方法（参数）<br />除了对象被放置到方法名之前，并且两者之间用一个点号隔开，方法调用与函数调用很类似。列表提供了几个方法，用于检查或者修改其中的内容。<br />1. append <br />append方法用于在列表末尾追加新的对象：<br />1<br />2<br />3lst=[1,2,3]<br />lst.append(2)<br />lst<br /><br /><br />1[1, 2, 3, 2]<br /><br /><br />2. count <br />count方法统计某个元素在列表中出现的次数：<br />1lst.count(2)<br /><br /><br />12<br /><br /><br />3. extend <br />extend方法可以在列表的末尾一次性追加另一个序列中的多个值。<br />1<br />2<br />3<br />4a=[1,2,3]<br />b=[4,5,6]<br />a.extend(b)<br />a<br /><br /><br />1[1, 2, 3, 4, 5, 6]<br /><br /><br />4. index <br />index方法用于从列表中找出某个值第一个匹配项的索引位置：<br />1<br />2knights=['we','are','the','knights']<br />knights.index('are')<br /><br /><br />11<br /><br /><br />5. insert <br />insert方法用于将对象插入到列表中：<br />1<br />2<br />3a=[1,2,4]<br />a.insert(2,'three')<br />a<br /><br /><br />1[1, 2, 'three', 4]<br /><br /><br />6. pop <br />pop方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值 ：<br />1a.pop()<br /><br /><br />14<br /><br /><br />1a<br /><br /><br />1[1, 2, 'three']<br /><br /><br />1a.pop(1)<br /><br /><br />12<br /><br /><br />1a<br /><br /><br />1[1, 'three']<br /><br /><br />使用pop方法可以实现一种常见的数据结构—栈。栈的原理就像堆放盘子那样，只能在顶部放一个盘子。同样，也只能从顶部拿走一个盘子。对于上述两个栈操作（放入和移除）-入栈（push）和出栈（pop）。Python没有入栈方法，但可以用append方法替代。<br />1<br />2<br />3x=[1,2,3]<br />x.append(x.pop())<br />x<br /><br /><br />1[1, 2, 3]<br /><br /><br />7. remove <br />remove方法会移除列表中某个值的第一个匹配项 ：<br />1<br />2x.remove(2)<br />x<br /><br /><br />1[1, 3]<br /><br /><br />remove是一个没有返回值的原位置改变方法，这与pop方法不同。<br />8. reverse <br />reverse方法会将列表中的元素反向存放 ：<br />1<br />2x.reverse()<br />x<br /><br /><br />1[3, 1]<br /><br /><br />9. sort <br />sort方法会将列表中的元素进行排序 ：<br />1<br />2<br />3y=[4,2,3,1]<br />y.sort()<br />y<br /><br /><br />1[1, 2, 3, 4]<br /><br /><br />另一种获取已排序的列表副本的方法是，使用sorted函数：<br />1<br />2<br />3x=[4,2,3,1]<br />y=sorted(x)<br />x<br /><br /><br />1[4, 2, 3, 1]<br /><br /><br />1y<br /><br /><br />1[1, 2, 3, 4]<br /><br /><br />1<br />2y.reverse()<br />y<br /><br /><br />1[4, 3, 2, 1]<br /><br /><br />3 元组：不可变序列<br />可以用逗号分隔一些值，自动创建元组：<br />11,2,3<br /><br /><br />1(1, 2, 3)<br /><br /><br />元组也能通过圆括号括起来：<br />1(1,2,3)<br /><br /><br />1(1, 2, 3)<br /><br /><br />3.1 tuple函数<br />以一个序列为参数并把它转换为元组：<br />1tuple([1,2,3])<br /><br /><br />1(1, 2, 3)<br /><br /><br />1tuple('abc')<br /><br /><br />1('a', 'b', 'c')<br /><br /><br />3.2 基本元组操作<br />除了创建元组和访问元组元素之外，也没有太多其他操作：<br />1<br />2x=1,2,3<br />x[1:3]<br /><br /><br />1(2, 3)<br /><br /><br />4 字符串<br />4.1 字符串格式化<br />字符串格式化使用字符串格式化操作符，即百分号% 来实现。在% 的左侧放置一个字符串（格式化字符串），而右侧则放置希望格式化的值。可以使用一个值，比如一个字符串或数字，也可以使用多个值的元组或字典。一般情况下使用元组：<br />1<br />2<br />3format='hello, % s. % s enough for ya?'<br />values=('world','Hot')<br />print format %  values<br /><br /><br />1hello, world. Hot enough for ya?<br /><br /><br />格式化字符串% s部分称为转换说明符，它们标记了需要插入转换值的位置。s表示值会被格式化为字符串-如果不是字符串，则会用str将其转换为字符串。   <br />如果要格式化实数（浮点数），可以使用f说明符类型，同时提供所需要的精度：一个句点再加上希望保留的小数位数。<br />1<br />2<br />3format='Pi with four decimals:% .4f'<br />from math import pi<br />print format %  pi<br /><br /><br />1Pi with four decimals:3.1416<br /><br /><br />1'Pi :% 10f' %  pi   #字段宽 10<br /><br /><br />1'Pi :  3.141593'<br /><br /><br />1'Pi :% 010.2f' %  pi #用0进行空位填充<br /><br /><br />1'Pi :0000003.14'<br /><br /><br />1'% -10.2f' %  pi   #减号用来左对齐数值<br /><br /><br />1'3.14      '<br /><br /><br />加号表示不管是正数还是负数都标示出符号（同样是在对齐时很有用）：<br />1print ('% +5d' %  10)+'\\n'+('% +5d' %  -10)<br /><br /><br />1<br />2  +10<br />  -10<br /><br /><br />4.2 字符串方法<br />字符串的方法很多，这是因为字符串从string模块中“继承”了很多方法。  <br />1. find <br />find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。<br />1'hello, world!'.find('wor')<br /><br /><br />17<br /><br /><br />2. join <br />join方法是非常重要的字符串方法，它是split方法的逆方法。<br />1<br />2seq=[1,2,3]<br />'+'.join(seq)  #连接数字列表<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10---------------------------------------------------------------------------<br /><br />TypeError                                 Traceback (most recent call last)<br /><br /><ipython-input-79-057454ab231d> in <module>()<br />      1 seq=[1,2,3]<br />----> 2 '+'.join(seq)  #连接数字列表<br /><br /><br />TypeError: sequence item 0: expected string, int found<br /><br /><br />1<br />2seq=['1','2','3']<br />'+'.join(seq)  #连接字符串列表<br /><br /><br />1'1+2+3'<br /><br /><br />可以看到，需要添加的队列元素都必须是字符串。<br />3. lower <br />lower方法返回字符串的小写字母版。<br />1'Hello, World!'.lower()<br /><br /><br />1'hello, world!'<br /><br /><br />4. replace <br />replace方法返回某字符串的所有匹配项均被替换之后得到字符串。<br />1'This is a shoe'.replace('s','aaa')<br /><br /><br />1'Thiaaa iaaa a aaahoe'<br /><br /><br />5. split <br />split方法是join的逆方法，用来将字符串分割成序列。如果不提供任何分隔符，程序会把所有空格作为分隔符（空格、制表、换行等）。<br />1'1+2+3'.split('+')<br /><br /><br />1['1', '2', '3']<br /><br /><br />6. strip <br />strip方法返回去除两侧（不包括内部）空格的字符串：<br />1'      hello world       '.strip()<br /><br /><br />1'hello world'<br /><br /><br />5 字典<br />字典是一种通过名字(键)引用值的数据结构。这种结构类型称为映射（mapping）。<br />5.1 创建和使用字典<br />字典可以通过下面的方式创建：<br />1<br />2phonebook={'Alice':'2341','Beth':9102}<br />phonebook<br /><br /><br />1{'Alice': '2341', 'Beth': 9102}<br /><br /><br />5.2 dict函数<br />可以用dict函数，通过其他映射（比如其他字典）或者（键，值）这样的序列对建立字典。<br />1<br />2<br />3items=[('name','Gumby'),('age','42')]<br />d=dict(items)<br />d<br /><br /><br />1{'age': '42', 'name': 'Gumby'}<br /><br /><br />dict函数也可以通过关键字参数来创建字典，如下：<br />1<br />2d=dict(name='Gumby',age=42)<br />d<br /><br /><br />1{'age': 42, 'name': 'Gumby'}<br /><br /><br />5.3 基本字典操作<br />字典的基本行为在很多方面与序列类似：  <br />len(d)返回d中项（键-值对）的数量；    <br />d[k]返回关联到键k上的值；   <br />d[k]=v将值v关联到键k上； <br />del d[k]删除键为k的项； <br />k in d检查d中是否含有键为k的项。<br />1<br />2x=[]<br />x[42]='hello'<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10---------------------------------------------------------------------------<br /><br />IndexError                                Traceback (most recent call last)<br /><br /><ipython-input-4-f0295807ecda> in <module>()<br />      1 x=[]<br />----> 2 x[42]='hello'<br /><br /><br />IndexError: list assignment index out of range<br /><br /><br />1<br />2<br />3x={}<br />x[42]='hello'<br />x<br /><br /><br />1{42: 'hello'}<br /><br /><br />上面将字符串’hello’关联到一个空列表的42号位置上—这显然是不可能的，因为这个位置根本不存在。为了将其变为可能，必须用[None]*43或者其他方式初始化x，而不能仅使用[]。但是，可将’hello’关联到空字典的键42上。<br />5.4 字典的格式化字符串<br />字典的格式化就是在每个转换说明符中的% 字符后面，可以加上（用圆括号括起来的）键，后面再跟上其他说明元素。<br />1<br />2phonebook={'Alice':'2341','Beth':9102}<br />phonebook<br /><br /><br />1{'Alice': '2341', 'Beth': 9102}<br /><br /><br />1\"Beth's phone number is % (Beth)s.\" %  phonebook<br /><br /><br />1\"Beth's phone number is 9102.\"<br /><br /><br />5.5 字典方法<br />1. clear <br />clear方法清除字典中所有的项。这是个原地操作（类似于list.sort）,所以无返回值（或返回None）。<br />2. get <br />get方法是个更宽松的访问字典项的方法。一般来说，如果试图访问字典中不存在的项时会出错：<br />1<br />2d={}<br />print d['name']<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10---------------------------------------------------------------------------<br /><br />KeyError                                  Traceback (most recent call last)<br /><br /><ipython-input-8-4f402a46f272> in <module>()<br />      1 d={}<br />----> 2 print d['name']<br /><br /><br />KeyError: 'name'<br /><br /><br />而用get就不会：<br />1print d.get('name')<br /><br /><br />1None<br /><br /><br />可以看到，当使用get访问一个不存在的键时，没有任何异常，而得到了None值，还可以自定义”默认“值，替换None:<br />1d.get('name','N/A')<br /><br /><br />1'N/A'<br /><br /><br />3. has_key <br />has_key方法可以检测字典中是否含有给出的键。表达式d.has_key(k)相当于表达式k in d。<br />4. items和iteritems <br />items方法将所有字典项以列表方式返回，这些列表项中的每一项都来自于（键，值）。但是项在返回时并没有特殊的顺序。<br />1<br />2d={'title':'Python web site','url':'http://www.python.org','spam':0}<br />d.items()<br /><br /><br />1[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python web site')]<br /><br /><br />iteritems方法的作用大致相同，但是会返回一个迭代器对象而不是列表：<br />1<br />2it=d.iteritems()<br />it<br /><br /><br />1<dictionary-itemiterator at 0x4324408><br /><br /><br />1list(it)  #Convert the iterator to a list<br /><br /><br />1[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python web site')]<br /><br /><br />在很多情况下使用iteritems更高效（尤其是想要迭代结果的情况下）。<br />5. keys和iterkeys <br />keys方法将字典中的键以列表形式返回，而iterkeys则返回针对键的迭代器。<br />1d.keys()<br /><br /><br />1['url', 'spam', 'title']<br /><br /><br />1<br />2m=d.iterkeys()<br />m<br /><br /><br />1<dictionary-keyiterator at 0x43244a8><br /><br /><br />1list(m)<br /><br /><br />1['url', 'spam', 'title']<br /><br /><br />6. pop <br />pop方法用来获得对应于给定键的值，然后将这个键-值对从字典中移除。<br />7. values和itervalues <br />values方法以列表的形式返回字典中的值（itervalues返回值的迭代器）。<br />8. setdefault <br />setdefault方法在某种程度上类似于get方法，就是能够获得与给定键相关联的值，除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值。<br />1<br />2<br />3d={}<br />d.setdefault('name','N/A')<br />d<br /><br /><br />1{'name': 'N/A'}<br /><br /><br />1<br />2d['name']='Gumby'<br />d.setdefault('name','N/A')<br /><br /><br />1'Gumby'<br /><br /><br />1d<br /><br /><br />1{'name': 'Gumby'}<br /><br /><br />6 小结<br />1<br /><br />","tags": "python 列表 元组 字符串 字典 2","url": "blog/python_beginning/2list_tuple_string_dict.html"},
{"title": "条件和循环语句","text": "<br />前面已经介绍过了几个基本语句（print语句、import语句、赋值语句）。接下来你会看到列表推导式（list comprehension）如何扮演循环和条件语句的角色。最后介绍pass、del和exec语句的用法。<br />1 语句块：缩排的乐趣<br />语句块是在条件为真（条件语句）时执行或者执行多次（循环语句）的一组语句。在代码前放置空格来缩进语句即可创建语句块。    <br />注意 使用tab字符也可以缩进语句块。而一个tab字符位置为8个空格，但是标准且推荐的方式是只用空格，尤其是在每个缩进需要4个空格的时候。<br />2 条件和条件语句<br />这部分会介绍让程序选择是否执行语句块的方法。<br />2.1 布尔变量的作用<br />下面的值在作为布尔表达式的时候，会被解释器看做假（false）：    <br />False None 0 “” () [] {}  <br />其他的一切都被解释为真。  <br />布尔值True和False属于布尔类型，bool函数（和list、str、tuple一样）可以用来转换其他值。<br />1bool('ok')<br /><br /><br />1True<br /><br /><br />1bool(8)<br /><br /><br />1True<br /><br /><br />1bool('')<br /><br /><br />1False<br /><br /><br />2.2 条件执行和if语句、else子句、elif子句<br />1<br />2<br />3<br />4<br />5<br />6<br />7num=input('Enter a number:')<br />if num>0:<br />    print 'positive'<br />elif num<0:<br />    print 'negative'<br />else:<br />    print 'zero'<br /><br /><br />1<br />2Enter a number:8<br />positive<br /><br /><br />2.3 更复杂的条件<br />1. 比较运算符 <br />x==y  <br />x < y  <br />x>=y  <br />x!=y <br />x is y  <br />x is not y（x和y是不同的对象）  <br />x in y   <br />x not in y(x不是y容器（例如，序列）的成员)   <br />注意： 使用==运算符来判定两个对象是否相等，使用is判定两者是否等同（同一个对象）。<br />2. 布尔运算符 <br />and, or, not就是所谓的布尔运算符。<br />3 循环<br />3.1 while循环<br />1<br />2<br />3<br />4x=1<br />while x<=3:<br />    print x<br />    x+=1<br /><br /><br />1<br />2<br />31<br />2<br />3<br /><br /><br />3.2 for循环<br />1<br />2<br />3nums=[1,2,3]<br />for n in nums:<br />    print n<br /><br /><br />1<br />2<br />31<br />2<br />3<br /><br /><br />因为迭代（循环的另外一种说法）某范围的数字是很常见的，所以有个内建的范围函数供使用：<br />1range(0,10)<br /><br /><br />1[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br /><br /><br />range函数的工作方式类似于分片。它包含下限，但不包含上限。如果希望下限为0，可以只提供上限：<br />1range(10)<br /><br /><br />1[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br /><br /><br />1range(10,0,-2)  #-2表示步长<br /><br /><br />1[10, 8, 6, 4, 2]<br /><br /><br />3.3 循环遍历字典元素<br />一个简单的for语句就能循环字典的所有键：<br />1<br />2<br />3d ={'x':1,'y':2,'z':3}<br />for key in d:<br />    print key,'corresponds to', d[key]<br /><br /><br />1<br />2<br />3y corresponds to 2<br />x corresponds to 1<br />z corresponds to 3<br /><br /><br />如果只需要值，可以使用d.values替代d.keys。d.items方法会将键-值对作为元组返回，for循环的一大好处就是可以循环中使用序列解包：<br />1<br />2for key, value in d.items():<br />    print key,'corresponds to', value<br /><br /><br />1<br />2<br />3y corresponds to 2<br />x corresponds to 1<br />z corresponds to 3<br /><br /><br />3.4 翻转和排序迭代<br />reversed和sorted这两个函数同列表的reverse和sort方法类似，但能作用于任何序列或可迭代对象上，不是原地修改对象，而是返回翻转或排序后的版本：<br />1sorted([4,3,6,8])<br /><br /><br />1[3, 4, 6, 8]<br /><br /><br />1reversed([4,3,6,8])<br /><br /><br />1<listreverseiterator at 0x411ae48><br /><br /><br />1list(reversed([4,3,6,8]))<br /><br /><br />1[8, 6, 3, 4]<br /><br /><br />注意：虽然sorted函数返回列表，reversed函数却返回一个可迭代对象。它们大可在for循环以及join方法中使用，而不会有任何问题。不过却不能直接对它使用索引、分片及调用列表的方法。<br />3.5 并行迭代<br />程序可以同时迭代两个序列。比如有下面两个列表：<br />1<br />2<br />3<br />4names=['anne','beth','george','damon']<br />ages=[12,45,32,102]<br />for i in range(len(names)):<br />    print names[i],'is',ages[i],'years old'<br /><br /><br />1<br />2<br />3<br />4anne is 12 years old<br />beth is 45 years old<br />george is 32 years old<br />damon is 102 years old<br /><br /><br />而内建的zip函数可以用来进行并行迭代，可以把两个序列“压缩”在一起，然后返回一个元组的列表：<br />1zip(names,ages)<br /><br /><br />1[('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]<br /><br /><br />现在可以在循环中解包元组：<br />1<br />2for name, age in zip(names,ages):<br />    print name,'is',age,'years old'<br /><br /><br />1<br />2<br />3<br />4anne is 12 years old<br />beth is 45 years old<br />george is 32 years old<br />damon is 102 years old<br /><br /><br />3.6 跳出循环<br />1. break <br />结束（跳出）循环可以使用break语句。   <br />2. continue <br />continue会让当前的迭代结束，“跳”到下一轮循环的开始。<br />4 列表推导式—轻量级循环<br />列表推导式（类似于数学术语中的集合推导式）是利用其他列表创建新列表的一种方法。它的工作方式类似于for循环：<br />1[x*x for x in range(10)]<br /><br /><br />1[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br /><br /><br />如果只想打印出那些能被3整除的平方数呢？可以使用模除运算符—y% 3。<br />1[x*x for x in range(10) if x %  3 ==0]<br /><br /><br />1[0, 9, 36, 81]<br /><br /><br />1[(x,y) for x in range(2) for y in range(3)]<br /><br /><br />1[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]<br /><br /><br />5 pass、del和exec语句<br />1pass    #该语句什么事情也不做<br /><br /><br />1<br />2<br />3x=1<br />del x<br />x<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11---------------------------------------------------------------------------<br /><br />NameError                                 Traceback (most recent call last)<br /><br /><ipython-input-25-0ba4a8505457> in <module>()<br />      1 x=1<br />      2 del x<br />----> 3 x<br /><br /><br />NameError: name 'x' is not defined<br /><br /><br />del语句不仅会移除一个对象的引用，也会移除那个名字本身。    <br />有些时候可能需要动态地创造Python代码，然后将其作为语句执行或作为表达式计算。而exec语句能执行存储在字符串中的Python代码。eval语句会计算Python表达式，并且返回结果值。<br />1exec 'print \"Hello, world\"'<br /><br /><br />1Hello, world<br /><br /><br />1<br />2<br />3from math import sqrt<br />exec 'sqrt=1'<br />sqrt(4)<br /><br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11---------------------------------------------------------------------------<br /><br />TypeError                                 Traceback (most recent call last)<br /><br /><ipython-input-27-fe92a6d219bc> in <module>()<br />      1 from math import sqrt<br />      2 exec 'sqrt=1'<br />----> 3 sqrt(4)<br /><br /><br />TypeError: 'int' object is not callable<br /><br /><br />exec语句最有用的地方在于可以动态地创造代码字符串。如果字符串是从其他地方获得的—很可能是用户—那么就不能确定其中到底包含什么代码。所以为了安全起见，可以增加一个字典，起到命名空间的作用。<br />1<br />2<br />3<br />4from math import sqrt<br />scope={}<br />exec 'sqrt=1' in scope<br />sqrt(4)<br /><br /><br />12.0<br /><br /><br />1scope['sqrt']<br /><br /><br />11<br /><br /><br />可以通过增加in scope来实现，其中scope就是起到放置代码字符串命名空间作用的字典。可以看到，潜在的破坏性代码并不会覆盖sqrt函数，原来的函数能正常工作，而通过exec赋值的变量sqrt只能在它的作用域内有效。<br />1eval('6+18*2')  #执行表达式<br /><br /><br />142<br /><br /><br />1<br />2exec('x=6+18*2')  #执行语句<br />x<br /><br /><br />142<br /><br /><br />6 小结<br />1<br /><br />","tags": "python 语句 列表推导式 3","url": "blog/python_beginning/3if_for_while_statement.html"},
{"title": "模块","text": "<br />Python的标准安装包括一组模块（module），称为标准库（standard library）。本章将介绍标准库中模块的功能。<br />1 模块<br />现在你已经知道如何创建和执行自己的程序（或脚本）了，也学会了怎么用import从外部模块获取函数并且为自己的程序所用：      <br />1<br />2import math<br />math.sin(0)<br /><br /><br />10.0<br /><br /><br />怎么编写自己的模块呢？<br />1.1 模块就是程序<br />任何Python程序都可以作为模块导入。假如你写了一个如下的程序，并且将它保存为hello.py文件。<br />1<br />2<br />3#一个简单的模块<br />#hello.py     <br />print \"Hello, world!\"<br /><br /><br />程序保存的位置很重要，假如保存在c:/python。可以执行下面的代码，告诉解释器在哪里寻找模块了（以Windows目录为例）：<br />1<br />2import sys<br />sys.path.append('c:/python')<br /><br /><br />通过上步告诉解释器：除了从默认的目录中寻找之外，还需要从目录c:/python中寻找模块。完成之后，就能导入自己的模块了：<br />>>> import hello   <br />Hello, world! <br />如你所见，在导入模块的时候，其中的代码被执行了。不过，如果再次导入该模块，就什么都不会发生了:    <br />>>> import hello   <br />>>><br />为什么这次没用了？因为导入模块并不意味着在导入时执行某些操作（比如打印文本）。它们主要用于定义，比如变量、函数和类等。此外，因为只需要定义这些东西一次，导入模块多次和导入一次的效果是一样的。<br />1.2 模块用于定义<br />模块（像类一样）可以保持自己的作用域。这就意味着模块中定义的所有类和函数以及赋值后变量都成为了模块的特性。 <br />1.2.1 在模块中定义函数 <br />1<br />2<br />3<br />4#包含函数的简单模块<br />#hello2.py     <br />def hello():      <br />    print \"Hello, world!\"       <br /><br /><br />可以像下面这样导入：   <br />>>>import hello2   <br />模块会被执行，这意味着hello函数在模块的作用域内被定义了。因此可以通过以下方式来访问函数： <br />>>>hello2.hello()  <br />Hello, world!<br />为什么要这样做呢？为什么不在主程序中定义好一切呢？主要原因是代码重用（code reuse）。如果把代码放在模块中，就可以在多个程序中使用这些代码了。因此请记住：为了让代码可重用，请将它模块化！<br />1.2.2 在模块中添加测试代码 <br />模块用来定义函数、类和其他一些内容，但是有些时候，在模块中添加一些检查模块本身是否正常工作的测试代码是很有用的。如下：<br />1<br />2<br />3<br />4<br />5<br />6#带有问题测试代码的简单模块<br />#hello3.py     <br />def hello():      <br />    print \"Hello, world!\"<br />#A test:<br />hello()<br /><br /><br />>>>import hello3  <br />Hello, world!  <br />>>>hello3.hello()   <br />Hello, world!<br />如果将hello3作为模块导入，测试代码就会被执行。为了避免这种情况关键在于：“告知”模块本身是作为程序运行还是导入到其他程序。为了实现这一点，需要使用__name__变量：<br />1__name__<br /><br /><br />1'__main__'<br /><br /><br />hello3.__name__ <br />‘hello3’<br />如上，在“主程序”中，变量__name__的值是‘__main__’。而在导入的模块中，这个值就被设定为模块的名字。因此，为了让模块的测试代码更加好用，可以将其放置在if语句中：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8#使用条件测试代码的模块<br />#hello4.py     <br />def hello():      <br />    print \"Hello, world!\"<br />def test():<br />    hello()<br />if __name__=='__main__':<br />    test()<br /><br /><br />1.3 包<br />为了组织好模块，可以将它们分组为包（package）。当模块存储在文件中时（扩展名.py），包就是模块所在的目录。为了让Python将其作为包对待，它必须包含一个命名为__init__.py的文件(模块)。如果将它作为普通模块导入的话，文件的内容就是包的内容。比如有个名为constants的包，文件constants/__init__.py包括语句PI=3.14，那么你可以像下面这么做：<br />1<br />2import constants<br />print constants.PI<br /><br /><br />2 探究模块<br />探索模块最直接的方式就是在Python解释器中研究它们。当然，要做的第一件事就是导入它。比如：<br />1import copy<br /><br /><br />没有引发异常—所以它是存在的。但是它能做什么？又有什么？<br />2.1 使用dir<br />查看模块包含的内容可以使用dir函数，它会将对象（模块的所有函数、类、变量等）的所有特性列出。一些特性以下划线开始—暗示（约定俗成）它们并不是为在模块外部使用而准备的。所以让我们用列表推导式过滤掉它们：<br />1[n for n in dir(copy) if not n.startswith('_')]<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9['Error',<br /> 'PyStringMap',<br /> 'copy',<br /> 'deepcopy',<br /> 'dispatch_table',<br /> 'error',<br /> 'name',<br /> 't',<br /> 'weakref']<br /><br /><br />1copy.__name__<br /><br /><br />1'copy'<br /><br /><br />1copy.__all__<br /><br /><br />1['Error', 'copy', 'deepcopy']<br /><br /><br />__all__是在copy模块内部被设置的，如下：  <br />__all__=[‘Error’, ‘copy’, ‘deepcopy’]   <br />那么它为什么在那呢？它定义了模块的公有接口（public interface）。更准确地说，它告诉解释器：从模块导入所有名字代表什么含义。如果你使用如下代码：  <br />from copy import *   <br />那么，你只能使用__all__变量中的3个函数。要导入PyStringMap函数的话，你就得显式地实现，比如from copy import PyStringMap。 <br />在编写模块的时候，像设置__all__这样的技术是相对有用的。因为模块中可能会有一大堆其他程序不需要或不想要的变量、函数和类，__all__会“客气地”将它们过滤掉。如果没有设定__all__，用import *语句默认将会输出模块中所有不以下划线开头的全局名称。<br />2.2 用help获取帮助<br />1help(copy.copy)<br /><br /><br />1<br />2<br />3<br />4<br />5<br />6Help on function copy in module copy:<br /><br />copy(x)<br />    Shallow copy operation on arbitrary Python objects.<br /><br />    See the module's __doc__ string for more info.<br /><br /><br />1copy.copy.__doc__<br /><br /><br />1\"Shallow copy operation on arbitrary Python objects.\\n\\n    See the module's __doc__ string for more info.\\n    \"<br /><br /><br />文档字符串是写在函数开头并且简述函数功能的字符串。这个字符串可以通过函数的__doc__属性引用。模块和类都有文档字符串（写在开头）。   <br />使用help与直接检查文档字符串相比，它的好处在于会获得更多信息，比如函数签名（也就是所带的参数）。<br />2.3 阅读源代码<br />要了解模块，是不能脱离源代码的。阅读源代码，是学习Python最好的方式。那么源代码在哪里？如果希望阅读标准模块copy的源代码，可以通过检查模块的__file__属性：<br />1copy.__file__<br /><br /><br />1'c:\\\\python27\\\\lib\\\\copy.pyc'<br /><br /><br />注意，一些模块并不包含任何可以阅读的Python源代码。它们可能已经融入到解释器内了（比如sys模块），或者可能是使用C语言写成的。<br />3 标准库<br />安装Python后，你就免费获得了很多有用的模块。<br />3.1 sys<br />sys模块让你能够访问与Python解释器联系紧密的变量和函数<br />1<br /><br />","tags": "python 标准库 sys os 6","url": "blog/python_beginning/6module.html"}]};